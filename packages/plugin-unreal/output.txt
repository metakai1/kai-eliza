Project Path: plugin-unreal

Source Tree:

```
plugin-unreal
├── tsup.config.ts
├── archive
│   ├── unreal
│   │   ├── version1
│   │   │   ├── land_memory_system.ts
│   │   │   ├── types.ts
│   │   │   ├── logging.ts
│   │   │   └── land_database_adapter.ts
│   │   ├── version2
│   │   │   ├── land_memory_system.ts
│   │   │   ├── types.ts
│   │   │   ├── logging.ts
│   │   │   └── land_database_adapter.ts
│   │   ├── design
│   │   │   └── code
│   │   │       ├── v2 land_memorysystem.ts
│   │   │       ├── land_memorysystem.ts
│   │   │       └── land_database_adapter.ts
│   │   └── property-search-design
│   │       ├── intialSearchAction.ts
│   │       ├── searchContextProvider.ts
│   │       ├── land_memory_system.ts
│   │       ├── types.ts
│   │       ├── interfaces
│   │       │   └── ILandDataProvider.ts
│   │       ├── runtime-property-database2.test.ts
│   │       ├── searchManager.ts
│   │       ├── adapters
│   │       │   └── PostgresLandDataProvider.ts
│   │       ├── searchProcessingAction.ts
│   │       └── land_database_adapter.ts
│   ├── plugin-dominos
│   │   ├── plugin-spreadsheet
│   │   │   ├── vitest.config.ts
│   │   │   └── src
│   │   │       ├── utils.ts
│   │   │       ├── index.ts
│   │   │       ├── services
│   │   │       │   └── index.ts
│   │   │       ├── types.ts
│   │   │       ├── storage
│   │   │       │   └── memory-storage.ts
│   │   │       ├── storage.ts
│   │   │       ├── errors.ts
│   │   │       └── services.ts
│   │   ├── tsup.config.ts
│   │   └── src
│   │       ├── index.ts
│   │       ├── PizzaOrderManager.ts
│   │       ├── actions
│   │       │   ├── updateOrder.ts
│   │       │   ├── index.ts
│   │       │   ├── updateCustomer.ts
│   │       │   ├── endOrder.ts
│   │       │   ├── confirmOrder.ts
│   │       │   └── startOrder.ts
│   │       ├── types.ts
│   │       └── providers
│   │           ├── index.ts
│   │           └── pizzaOrder.ts
│   └── adapters
│       └── PostgresLandDataProvider.ts
├── src
│   ├── index.ts
│   ├── searchContextProvider.ts
│   ├── types.ts
│   ├── interfaces
│   │   └── ILandDataProvider.ts
│   ├── initialSearchAction.ts
│   ├── endSearchAction.ts
│   ├── database
│   │   ├── land_memory_system.ts
│   │   └── land_database_adapter.ts
│   ├── nft
│   │   ├── types_NFT.ts
│   │   └── ReservoirAPI.ts
│   ├── searchManager.ts
│   ├── adapters
│   │   └── PostgresLandDataProvider.ts
│   └── searchProcessingAction.ts
└── scripts
    └── seed-database.ts

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/tsup.config.ts`:

```ts
import { defineConfig } from "tsup";

export default defineConfig({
    entry: ["src/index.ts"],
    outDir: "dist",
    sourcemap: true,
    clean: true,
    format: ["esm"], // Ensure you're targeting CommonJS
    external: [
        "dotenv", // Externalize dotenv to prevent bundling
        "fs", // Externalize fs to use Node.js built-in module
        "path", // Externalize other built-ins if necessary
        "@reflink/reflink",
        "@node-llama-cpp",
        "https",
        "http",
        "agentkeepalive",
        // Add other modules you want to externalize
    ],
});

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version1/land_memory_system.ts`:

```ts
import { elizaLogger, UUID, stringToUuid, splitChunks } from "@ai16z/eliza";
import { LandDatabaseAdapter } from "./land_database_adapter";
import { LandPlotMemory, LandSearchParams, DEFAULT_MATCH_COUNT, LandKnowledgeItem } from "./types";
import { LAND_ROOM_ID, LAND_AGENT_ID, AGENT_ID } from "./types";
import { v4 as uuidv4 } from 'uuid';

export const LAND_QUERY_SYSTEM_PROMPT = `
You are a real estate search assistant for a futuristic city. Convert natural language queries into structured search parameters.

Given a user query, respond with a JSON object containing:
1. A natural language description for embedding matching
2. Search metadata parameters

Example Response Format:
{
    "searchText": "Large plot in Nexus neighborhood close to ocean with tall building potential",
    "metadata": {
        "neighborhood": "Nexus",
        "minPlotArea": 5000,
        "maxOceanDistance": 500,
        "minFloors": 50
    }
}

Keep the searchText natural and descriptive while being specific about requirements.
`;

export class LandMemorySystem {
    constructor(
        private readonly database: LandDatabaseAdapter,
        private readonly embedder: {
            embedText: (text: string) => Promise<number[]>;
        }
    ) {}

    /**
     * Converts a CSV row into a natural language description for embedding
     */
    private generatePlotDescription(plot: any): string {
        return `${plot.Name} is a ${plot['Plot Size']} ${plot['Zoning Type']} plot in ${plot.Neighborhood}. ` +
               `It is a ${plot['Building Size']} building with ${plot['Min # of Floors']} to ${plot['Max # of Floors']} floors. ` +
               `The plot area is ${plot['Plot Area (m²)']}m² with building heights from ${plot['Min Building Height (m)']}m to ${plot['Max Building Height (m)']}m. ` +
               `Located ${plot['Distance to Ocean']} from ocean (${plot['Distance to Ocean (m)']}m) and ${plot['Distance to Bay']} from bay (${plot['Distance to Bay (m)']}m).`;
    }

    /**
     * Create a new land memory from CSV data
     */

    async createLandMemoryFromCSV(csvRow: any): Promise<void> {
        try {
            const description = this.generatePlotDescription(csvRow);
            const embedding = await this.embedder.embedText(description);

            const memory: LandPlotMemory = {
                id: stringToUuid(`description`),  // TODO FIX THIS
                userId:  LAND_AGENT_ID,  // Since this is a system-generated memory
                agentId: LAND_AGENT_ID,
                roomId: LAND_ROOM_ID,
                content: {
                    text: description,
                    metadata: {
                        rank: parseInt(csvRow['Rank']),
                        name: csvRow['Name'],
                        neighborhood: csvRow['Neighborhood'],
                        zoning: csvRow['Zoning Type'],
                        plotSize: csvRow['Plot Size'],
                        buildingType: csvRow['Building Size'],
                        distances: {
                            ocean: {
                                meters: parseInt(csvRow['Distance to Ocean (m)']),
                                category: csvRow['Distance to Ocean']
                            },
                            bay: {
                                meters: parseInt(csvRow['Distance to Bay (m)']),
                                category: csvRow['Distance to Bay']
                            }
                        },
                        building: {
                            floors: {
                                min: parseInt(csvRow['Min # of Floors']),
                                max: parseInt(csvRow['Max # of Floors'])
                            },
                            height: {
                                min: parseFloat(csvRow['Min Building Height (m)']),
                                max: parseFloat(csvRow['Max Building Height (m)'])
                            }
                        },
                        plotArea: parseFloat(csvRow['Plot Area (m²)'])
                    }
                },
                embedding
            };

            await this.database.createLandMemory(memory);
        } catch (error) {
            elizaLogger.error('Error creating land memory:', {
                error: error instanceof Error ? error.message : String(error),
                csvRow
            });
            throw error;
        }
    }

    async searchPropertiesSimple(
        query: string,
        metadata: Partial<LandSearchParams> = {},
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {

            console.log('Search query:', query);
            const embedding = await this.embedder.embedText(query);

            console.log('Search query embedding:', embedding);

            const results = await this.database.searchLandByEmbedding(
                embedding,
                metadata
            );
            console.log('Search results:', results);
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error searching properties:', {
                error: error instanceof Error ? error.message : String(error),
                query,
                metadata
            });
            throw error;
        }
    }

    /**
     * Search for properties using natural language query and metadata filters
     */
    async searchProperties(
        query: string,
        metadata: Partial<LandSearchParams> = {},
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {

            //console.log('Search query:', query);
            const embedding = await this.embedder.embedText(query);

            //console.log('Search query embedding:', embedding);

            const results = await this.database.searchLandByCombinedCriteria(
                embedding,
                metadata
            );
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error searching properties:', {
                error: error instanceof Error ? error.message : String(error),
                query,
                metadata
            });
            throw error;
        }
    }

    /**
     * Get properties within a specific rarity range
     */
    async getPropertiesByRarity(
        minRank: number,
        maxRank: number,
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {
            const results = await this.database.getPropertiesByRarityRange(minRank, maxRank);
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error getting properties by rarity:', {
                error: error instanceof Error ? error.message : String(error),
                minRank,
                maxRank
            });
            throw error;
        }
    }

    /**
     * Creates a land memory and its fragments from a knowledge item
     */
    async setLandKnowledge(
        item: LandKnowledgeItem,
        chunkSize: number = 512,
        bleed: number = 20
    ): Promise<UUID> {
        try {
            // First create the main land memory
            const mainMemory: LandPlotMemory = {
                id: item.id,
                userId: LAND_AGENT_ID,
                agentId: LAND_AGENT_ID,
                roomId: LAND_ROOM_ID,
                content: item.content,
                embedding: await this.embedder.embedText(item.content.text)
            };
            await this.database.createLandMemory(mainMemory);

            // Then split into fragments if needed
            const preprocessed = item.content.text;
            const fragments = await splitChunks(preprocessed, chunkSize, bleed);

            // Create fragment memories
            let fragmentCounter = 0;
            for (const fragment of fragments) {
                fragmentCounter++;
                const fragmentMemory: LandPlotMemory = {
                    id: stringToUuid(`${item.id}-fragment-${fragmentCounter}`),
                    userId: LAND_AGENT_ID,
                    agentId: LAND_AGENT_ID,
                    roomId: LAND_ROOM_ID,
                    content: {
                        text: fragment,
                        metadata: item.content.metadata, // Keep the same metadata
                        source: item.id
                    },
                    embedding: await this.embedder.embedText(fragment)
        };
                console.log("fragment memory text:", fragmentMemory.content.text);
                await this.database.createLandMemory(fragmentMemory);
                console.log("Fragment memory embedding:", fragmentMemory.embedding);
            }
        return item.id;
        } catch (error) {
            elizaLogger.error('Error setting land knowledge:', {
                error: error instanceof Error ? error.message : String(error),
                item
            });
            throw error;
        }
    }

    async getLandKnowledgeById(id: UUID): Promise<LandKnowledgeItem | undefined> {
        const memory = await this.database.getLandMemoryById(id);
        if (!memory) return undefined;

        return {
            id: memory.id,
            content: memory.content,
 //           text: memory.text,
  //          metadata: memory.metadata
        };
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version1/types.ts`:

```ts
import { Memory, UUID } from "@ai16z/eliza";

export enum PlotSize {
    Nano = 'Nano',
    Micro = 'Micro',
    Small = 'Small',
    Medium = 'Medium',
    Large = 'Large',
    Mega = 'Mega',
    Giga = 'Giga'
}

export enum ZoningType {
    Residential = 'Residential',
    Commercial = 'Commercial',
    Industrial = 'Industrial',
    Mixed = 'Mixed',
    Special = 'Special',
    Legendary = 'Legendary'
}

export enum BuildingType {
    LowRise = 'LowRise',
    MidRise = 'MidRise',
    HighRise = 'HighRise',
    Skyscraper = 'Skyscraper',
    Megascraper = 'Megascraper'
}

export enum DistanceCategory {
    Close = 'Close',
    Medium = 'Medium',
    Far = 'Far'
}

export interface LandPlotMetadata {
    rank: number;
    name: string;
    neighborhood: string;
    zoning: ZoningType;
    plotSize: PlotSize;
    buildingType: BuildingType;
    distances: {
        ocean: {
            meters: number;
            category: DistanceCategory;
        };
        bay: {
            meters: number;
            category: DistanceCategory;
        };
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plotArea: number;
}

export interface LandPlotMemory extends Memory {
    id: UUID;
    content: {
        text: string;
        metadata: LandPlotMetadata;
        source?: UUID;  // Optional source UUID to track origin of fragments
    };
}

export interface LandSearchParams {
    roomId?: UUID;
    agentId?: UUID;
    neighborhoods?: string[];
    zoningTypes?: ZoningType[];
    plotSizes?: PlotSize[];
    buildingTypes?: BuildingType[];
    distances?: {
        ocean?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
        bay?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
    };
    building?: {
        floors?: {
            min?: number;
            max?: number;
        };
        height?: {
            min?: number;
            max?: number;
        };
    };
    rarity?: {
        rankRange?: {
            min?: number;
            max?: number;
        };
    };
}

export interface LandKnowledgeItem {
    id: UUID;
    content: {
        text: string;
        metadata: any;
    };
}

// Constants
export const AGENT_ID: `${string}-${string}-${string}-${string}-${string}` = '1459b245-2171-02f6-b436-c3c2641848e5';
export const LAND_TABLE = 'land_table';
export const LAND_ROOM_ID = AGENT_ID;
export const LAND_AGENT_ID = AGENT_ID;
export const DEFAULT_MATCH_THRESHOLD = 0.4;
export const DEFAULT_MATCH_COUNT = 20;

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version1/logging.ts`:

```ts
import { LandPlotMemory, LandPlotMetadata } from "./types";

function printLandMemory(memory: LandPlotMemory) {
    const metadata = memory.content.metadata;
    console.log(`
🏗️  Land Plot Memory
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ID: ${memory.id}
Name: ${metadata.name}
Rank: ${metadata.rank}
Location: ${metadata.neighborhood}

Properties:
• Plot Size: ${metadata.plotSize}
• Zoning: ${metadata.zoning}
• Building Type: ${metadata.buildingType}
• Plot Area: ${metadata.plotArea}m²

Building Details:
• Floors: ${metadata.building.floors.min}-${metadata.building.floors.max}
• Height: ${metadata.building.height.min}-${metadata.building.height.max}m

Distances:
• Ocean: ${metadata.distances.ocean.meters}m (${metadata.distances.ocean.category})
• Bay: ${metadata.distances.bay.meters}m (${metadata.distances.bay.category})

Description:
${memory.content.text}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`);
}

export { printLandMemory };
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version1/land_database_adapter.ts`:

```ts
import { PostgresDatabaseAdapter } from "@ai16z/adapter-postgres";
import { elizaLogger, UUID } from "@ai16z/eliza";
import {
    LandPlotMemory,
    LandSearchParams,
    LAND_TABLE,
    LAND_ROOM_ID,
    LAND_AGENT_ID,
    DEFAULT_MATCH_THRESHOLD
} from "./types";

const LAND_MEMORY_TYPE = 'land_plot';

export class LandDatabaseAdapter extends PostgresDatabaseAdapter {
    constructor(connectionConfig: any) {
        super(connectionConfig);
    }

    async init(): Promise<void> {
        await super.init();
        // Add any additional initialization specific to LandDatabaseAdapter if needed
    }

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        console.log("Creating land memory with :", memory.embedding);
        await this.createMemory(memory, LAND_MEMORY_TYPE, true, LAND_TABLE);
    }

    async getLandMemoryById(id: UUID): Promise<LandPlotMemory | undefined> {
        const memory = await super.getMemoryById(id, LAND_MEMORY_TYPE, LAND_TABLE);
        if (!memory) return undefined;
        return memory as LandPlotMemory;
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
        const memories = await this.getMemories({
            roomId,
            tableName: LAND_MEMORY_TYPE,
            dbTable: LAND_TABLE
        });
        return memories as LandPlotMemory[];
    }

    async removeLandMemory(memoryId: UUID): Promise<void> {
        await this.removeMemory(memoryId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.removeAllMemories(roomId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]> {
        let sql = `
            SELECT * FROM ${LAND_TABLE}
            WHERE type = $1
            AND content IS NOT NULL
        `;
        const values: any[] = [LAND_MEMORY_TYPE];
        let paramCount = 1;

        if (params.neighborhoods?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'neighborhood' = ANY($${paramCount}::text[])`;
            values.push(params.neighborhoods);
        }

        if (params.zoningTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'zoning' = ANY($${paramCount}::text[])`;
            values.push(params.zoningTypes);
        }

        if (params.plotSizes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'plotSize' = ANY($${paramCount}::text[])`;
            values.push(params.plotSizes);
        }

        if (params.buildingTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'buildingType' = ANY($${paramCount}::text[])`;
            values.push(params.buildingTypes);
        }

        if (params.distances?.ocean) {
            if (params.distances.ocean.maxMeters) {
                paramCount++;
                sql += ` AND (content->'metadata'->'distances'->'ocean'->>'meters')::int <= $${paramCount}`;
                values.push(params.distances.ocean.maxMeters);
            }
            if (params.distances.ocean.category) {
                paramCount++;
                sql += ` AND content->'metadata'->'distances'->'ocean'->>'category' = $${paramCount}`;
                values.push(params.distances.ocean.category);
            }
        }

        if (params.building?.floors) {
            if (params.building.floors.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'min')::int >= $${paramCount}`;
                values.push(params.building.floors.min);
            }
            if (params.building.floors.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'max')::int <= $${paramCount}`;
                values.push(params.building.floors.max);
            }
        }

        if (params.rarity?.rankRange) {
            if (params.rarity.rankRange.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int >= $${paramCount}`;
                values.push(params.rarity.rankRange.min);
            }
            if (params.rarity.rankRange.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int <= $${paramCount}`;
                values.push(params.rarity.rankRange.max);
            }
        }

        try {
            const { rows } = await this.query(sql, values);
            return rows.map(row => ({
                ...row,
                content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content
            }));
        } catch (error) {
            elizaLogger.error('Error in searchLandByMetadata:', {
                error: error instanceof Error ? error.message : String(error),
                params
            });
            throw error;
        }
    }
    async searchLandByEmbedding(
        embedding: number[],
        metadata: Partial<LandSearchParams>,
        similarity_threshold: number = DEFAULT_MATCH_THRESHOLD
    ): Promise<LandPlotMemory[]> {
        const semanticResults = await this.searchMemoriesByEmbedding(embedding, {
            tableName: LAND_MEMORY_TYPE,
            roomId: LAND_ROOM_ID,
            agentId: LAND_AGENT_ID,
            match_threshold: similarity_threshold,
            dbTable: LAND_TABLE
        });
         return semanticResults as LandPlotMemory[];
    }

    async searchLandByCombinedCriteria(
        embedding: number[],
        metadata: Partial<LandSearchParams>,
        similarity_threshold: number = DEFAULT_MATCH_THRESHOLD

    ): Promise<LandPlotMemory[]> {
        const semanticResults = await this.searchMemoriesByEmbedding(embedding, {
            tableName: LAND_MEMORY_TYPE,
            roomId: LAND_ROOM_ID,
            agentId: LAND_AGENT_ID,
            match_threshold: similarity_threshold,
            dbTable: LAND_TABLE
        });

        console.log('searchLandByCombinedCriteria Semantic Results:', semanticResults);


        if (Object.keys(metadata).length === 0) {
            return semanticResults as LandPlotMemory[];
        }

        console.log('searchLandByCombinedCriteria Metadata:', metadata);
        const metadataResults = await this.searchLandByMetadata({
            ...metadata,
            roomId: LAND_ROOM_ID,
            agentId: LAND_AGENT_ID
        });

        const semanticIds = new Set(semanticResults.map(r => r.id));
        const filteredResults = metadataResults.filter(r => semanticIds.has(r.id));
        return filteredResults;
    }

    async getPropertiesByRarityRange(
        minRank: number,
        maxRank: number
    ): Promise<LandPlotMemory[]> {
        return this.searchLandByMetadata({
            rarity: {
                rankRange: {
                    min: minRank,
                    max: maxRank
                }
            }
        });
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version2/land_memory_system.ts`:

```ts
import { elizaLogger, UUID, stringToUuid, splitChunks } from "@ai16z/eliza";
import { LandDatabaseAdapter } from "./land_database_adapter";
import { LandPlotMemory, LandSearchParams, DEFAULT_MATCH_COUNT, LandKnowledgeItem, LandPlotMetadata } from "./types";
import { LAND_ROOM_ID, LAND_AGENT_ID, AGENT_ID } from "./types";
import { v4 as uuidv4 } from 'uuid';

export const LAND_QUERY_SYSTEM_PROMPT = `
You are a real estate search assistant for a futuristic city. Convert natural language queries into structured search parameters.

Given a user query, respond with a JSON object containing:
1. A natural language description for embedding matching
2. Search metadata parameters

Example Response Format:
{
    "searchText": "Large plot in Nexus neighborhood close to ocean with tall building potential",
    "metadata": {
        "neighborhood": "Nexus",
        "minPlotArea": 5000,
        "maxOceanDistance": 500,
        "minFloors": 50
    }
}

Keep the searchText natural and descriptive while being specific about requirements.
`;

export class LandMemorySystem {
    private readonly roomId: UUID = LAND_ROOM_ID; // TODO: Make this dynamic
    private readonly agentId: UUID = LAND_AGENT_ID;
    private readonly userId: UUID = AGENT_ID;

    constructor(
        private readonly database: LandDatabaseAdapter,
        private readonly embedder: {
            embedText: (text: string) => Promise<number[]>;
        }
    ) {}

    // create function to remove all LandMemories
    async removeAllLandMemories(): Promise<void> {
        await this.database.removeAllLandMemories(LAND_ROOM_ID);
    }

    async createLandMemoryFromCSV(csvRow: any): Promise<void> {
        try {
            const metadata: LandPlotMetadata = {
                rank: parseInt(csvRow['Rank']),
                name: csvRow['Name'],
                neighborhood: csvRow['Neighborhood'],
                zoning: csvRow['Zoning Type'],
                plotSize: csvRow['Plot Size'],
                buildingType: csvRow['Building Size'],
                distances: {
                    ocean: {
                        meters: parseInt(csvRow['Distance to Ocean (m)']),
                        category: csvRow['Distance to Ocean']
                    },
                    bay: {
                        meters: parseInt(csvRow['Distance to Bay (m)']),
                        category: csvRow['Distance to Bay']
                    }
                },
                building: {
                    floors: {
                        min: parseInt(csvRow['Min # of Floors']),
                        max: parseInt(csvRow['Max # of Floors'])
                    },
                    height: {
                        min: parseFloat(csvRow['Min Building Height (m)']),
                        max: parseFloat(csvRow['Max Building Height (m)'])
                    }
                },
                plotArea: parseFloat(csvRow['Plot Area (m²)'])
            };

            await this.storeProperty(metadata);
        } catch (error) {
            elizaLogger.error('Error creating land memory:', {
                error: error instanceof Error ? error.message : String(error),
                csvRow
            });
            throw error;
        }
    }

    async searchPropertiesByQuery(
        query: string,
        metadata: Partial<LandSearchParams> = {},
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {

            console.log('Search query:', query);
            const embedding = await this.embedder.embedText(query);

            console.log('Search query embedding:', embedding);

            const results = await this.database.searchLandByEmbedding(
                embedding
            );
            console.log('Search results:', results);
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error searching properties:', {
                error: error instanceof Error ? error.message : String(error),
                query,
                metadata
            });
            throw error;
        }
    }

    async searchPropertiesByParams(searchParams: Partial<LandSearchParams> = {}): Promise<LandPlotMemory[]> {
        const results = await this.database.searchLandByMetadata(searchParams);
        return results;
    }

    /**
     * Get properties within a specific rarity range
     */
    async getPropertiesByRarity(
        minRank: number,
        maxRank: number,
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {
            const results = await this.database.getPropertiesByRarityRange(minRank, maxRank);
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error getting properties by rarity:', {
                error: error instanceof Error ? error.message : String(error),
                minRank,
                maxRank
            });
            throw error;
        }
    }

    async storePropertyItem(
        item: LandKnowledgeItem,
        chunkSize: number = 512,
        bleed: number = 20
    ): Promise<UUID> {
        try {
            // First create the main land memory
            const mainMemory: LandPlotMemory = {
                id: item.id,
                userId: this.userId,
                agentId: this.agentId,
                roomId: this.roomId,
                content: item.content
                //embedding: await this.embedder.embedText(item.content.text)
            };
            await this.database.createLandMemory(mainMemory);   
            return item.id;
        } catch (error) {
            elizaLogger.error('Error setting land knowledge:', {
                error: error instanceof Error ? error.message : String(error),
                item
            });
            throw error;
        }
    }

    async getLandKnowledgeById(id: UUID): Promise<LandKnowledgeItem | undefined> {
        const memory = await this.database.getLandMemoryById(id);
        if (!memory) return undefined;

        return {
            id: memory.id,
            content: memory.content,
 //           text: memory.text,
 //         metadata: memory.metadata
        };
    }

    async getPropertyDataById(id: UUID): Promise<LandPlotMemory | undefined> {
        const result = await this.database.getLandMemoryById(id);
        return result;
    }

    /**
     * Stores a property in the land memory system
     * @param metadata The land plot metadata to store
     * @returns The UUID of the stored property
     */
    async storeProperty(metadata: LandPlotMetadata): Promise<UUID> {
        const description = this.generatePropertyDescription(metadata);
        const knowledgeItem: LandKnowledgeItem = {
            id: stringToUuid(description+Date.now()),
            content: {
                text: description,
                metadata: metadata
            },
        };

        return await this.storePropertyItem(knowledgeItem);
    }

    /**
     * Generates a natural language description of a property from its metadata
     */
    private generatePropertyDescription(metadata: LandPlotMetadata): string {
        const description = `${metadata.name} is a ${metadata.plotSize} ${metadata.zoning} plot in ${metadata.neighborhood}. ` +
            `It is located ${metadata.distances.ocean.meters}m from the ocean and ${metadata.distances.bay.meters}m from the bay. ` +
            `The building can have between ${metadata.building.floors.min} and ${metadata.building.floors.max} floors, ` +
            `with heights from ${metadata.building.height.min}m to ${metadata.building.height.max}m. ` +
            `The plot area is ${metadata.plotArea}m².`;
        return description;
    }
}

    
    /**
     * Search for properties using natural language query and metadata filters
     */
/*     async searchProperties(
        metadata: Partial<LandSearchParams> = {},
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {
            const constructedQuery = this.generateQueryFromMetadata(metadata);

            //console.log('Search query:', query);
            const embedding = await this.embedder.embedText(constructedQuery);

            //console.log('Search query embedding:', embedding);

            const results = await this.database.searchLandByCombinedCriteria(
                embedding,
                metadata
            );
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error searching properties:', {
                error: error instanceof Error ? error.message : String(error),
                query,
                metadata
            });
            throw error;
        }
    } */

        /**
     * Creates a land memory and its fragments from a knowledge item
/*      */
 /*    async setLandKnowledge(
        item: LandKnowledgeItem,
        chunkSize: number = 512,
        bleed: number = 20
    ): Promise<UUID> {
        try {
            // First create the main land memory
            const mainMemory: LandPlotMemory = {
                id: item.id,
                userId: this.userId,
                agentId: this.agentId,
                roomId: this.roomId,
                content: item.content,
                embedding: await this.embedder.embedText(item.content.text)
            };
            await this.database.createLandMemory(mainMemory);

            // Then split into fragments if needed
            const preprocessed = item.content.text;
            const fragments = await splitChunks(preprocessed, chunkSize, bleed);

            // Create fragment memories
            let fragmentCounter = 0;
            for (const fragment of fragments) {
                fragmentCounter++;
                const fragmentMemory: LandPlotMemory = {
                    id: stringToUuid(`${item.id}-fragment-${fragmentCounter}`),
                    userId: LAND_AGENT_ID,
                    agentId: LAND_AGENT_ID,
                    roomId: LAND_ROOM_ID,
                    content: {
                        text: fragment,
                        metadata: item.content.metadata, // Keep the same metadata
                        source: item.id
                    },
                    embedding: await this.embedder.embedText(fragment)
        };
                console.log("fragment memory text:", fragmentMemory.content.text);
                await this.database.createLandMemory(fragmentMemory);
                console.log("Fragment memory embedding:", fragmentMemory.embedding);
            }
        return item.id;
        } catch (error) {
            elizaLogger.error('Error setting land knowledge:', {
                error: error instanceof Error ? error.message : String(error),
                item
            });
            throw error;
        }
    }
 */ 
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version2/types.ts`:

```ts
import { Memory, UUID } from "@ai16z/eliza";

export enum PlotSize {
    Nano = 'Nano',
    Micro = 'Micro',
    Small = 'Small',
    Medium = 'Medium',
    Large = 'Large',
    Mega = 'Mega',
    Giga = 'Giga'
}

export enum ZoningType {
    Residential = 'Residential',
    Commercial = 'Commercial',
    Industrial = 'Industrial',
    Mixed = 'Mixed',
    Special = 'Special',
    Legendary = 'Legendary'
}

export enum BuildingType {
    LowRise = 'LowRise',
    MidRise = 'MidRise',
    HighRise = 'HighRise',
    Skyscraper = 'Skyscraper',
    Megascraper = 'Megascraper'
}

export enum DistanceCategory {
    Close = 'Close',
    Medium = 'Medium',
    Far = 'Far'
}

export interface LandPlotMetadata {
    rank: number;
    name: string;
    neighborhood: string;
    zoning: ZoningType;
    plotSize: PlotSize;
    buildingType: BuildingType;
    distances: {
        ocean: {
            meters: number;
            category: DistanceCategory;
        };
        bay: {
            meters: number;
            category: DistanceCategory;
        };
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plotArea: number;
}

export interface LandPlotMemory extends Memory {
    id: UUID;
    content: {
        text: string;
        metadata: LandPlotMetadata;
        source?: UUID;  // Optional source UUID to track origin of fragments
    };
}

export interface LandSearchParams {
    roomId?: UUID;
    agentId?: UUID;
    names?: string[];
    neighborhoods?: string[];
    zoningTypes?: ZoningType[];
    plotSizes?: PlotSize[];
    buildingTypes?: BuildingType[];
    distances?: {
        ocean?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
        bay?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
    };
    building?: {
        floors?: {
            min?: number;
            max?: number;
        };
        height?: {
            min?: number;
            max?: number;
        };
    };
    rarity?: {
        rankRange?: {
            min?: number;
            max?: number;
        };
    };
}

export interface LandKnowledgeItem {
    id: UUID;
    content: {
        text: string;
        metadata: any;
    };
}

// Constants
export const AGENT_ID: `${string}-${string}-${string}-${string}-${string}` = '1459b245-2171-02f6-b436-c3c2641848e5';
export const LAND_TABLE = 'land_table';
export const LAND_ROOM_ID = AGENT_ID;
export const LAND_AGENT_ID = AGENT_ID;
export const LAND_USER_ID = AGENT_ID;
export const DEFAULT_MATCH_THRESHOLD = 0.4;
export const DEFAULT_MATCH_COUNT = 20;

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version2/logging.ts`:

```ts
import { LandPlotMemory, LandPlotMetadata } from "./types";

function printLandMemory(memory: LandPlotMemory) {
    const metadata = memory.content.metadata;
    console.log(`
🏗️  Land Plot Memory
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ID: ${memory.id}
Name: ${metadata.name}
Rank: ${metadata.rank}
Location: ${metadata.neighborhood}

Properties:
• Plot Size: ${metadata.plotSize}
• Zoning: ${metadata.zoning}
• Building Type: ${metadata.buildingType}
• Plot Area: ${metadata.plotArea}m²

Building Details:
• Floors: ${metadata.building.floors.min}-${metadata.building.floors.max}
• Height: ${metadata.building.height.min}-${metadata.building.height.max}m

Distances:
• Ocean: ${metadata.distances.ocean.meters}m (${metadata.distances.ocean.category})
• Bay: ${metadata.distances.bay.meters}m (${metadata.distances.bay.category})

Description:
${memory.content.text}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
`);
}

export { printLandMemory };
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/version2/land_database_adapter.ts`:

```ts
import { PostgresDatabaseAdapter } from "@ai16z/adapter-postgres";
import { elizaLogger, UUID } from "@ai16z/eliza";
import {
    LandPlotMemory,
    LandSearchParams,
    LAND_TABLE,
    LAND_ROOM_ID,
    LAND_AGENT_ID,
    DEFAULT_MATCH_THRESHOLD
} from "./types";

const LAND_MEMORY_TYPE = 'land_plot';

export class LandDatabaseAdapter extends PostgresDatabaseAdapter {
    constructor(connectionConfig: any) {
        super(connectionConfig);
    }

    async init(): Promise<void> {
        await super.init();
        // Add any additional initialization specific to LandDatabaseAdapter if needed
    }

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        console.log("Creating land memory with :", memory.embedding);
        await this.createMemory(memory, LAND_MEMORY_TYPE, true, LAND_TABLE);
    }

    async getLandMemoryById(id: UUID): Promise<LandPlotMemory | undefined> {
        const memory = await super.getMemoryById(id, LAND_MEMORY_TYPE, LAND_TABLE);
        if (!memory) return undefined;
        return memory as LandPlotMemory;
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
        const memories = await this.getMemories({
            roomId,
            tableName: LAND_MEMORY_TYPE,
            dbTable: LAND_TABLE
        });
        return memories as LandPlotMemory[];
    }

    async removeLandMemory(memoryId: UUID): Promise<void> {
        await this.removeMemory(memoryId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.removeAllMemories(roomId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]> {
        let sql = `
            SELECT * FROM ${LAND_TABLE}
            WHERE type = $1
            AND content IS NOT NULL
        `;
        const values: any[] = [LAND_MEMORY_TYPE];
        let paramCount = 1;

        if (params.neighborhoods?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'neighborhood' = ANY($${paramCount}::text[])`;
            values.push(params.neighborhoods);
        }

        if (params.zoningTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'zoning' = ANY($${paramCount}::text[])`;
            values.push(params.zoningTypes);
        }

        if (params.plotSizes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'plotSize' = ANY($${paramCount}::text[])`;
            values.push(params.plotSizes);
        }

        if (params.buildingTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'buildingType' = ANY($${paramCount}::text[])`;
            values.push(params.buildingTypes);
        }

        if (params.distances?.ocean) {
            if (params.distances.ocean.maxMeters) {
                paramCount++;
                sql += ` AND (content->'metadata'->'distances'->'ocean'->>'meters')::int <= $${paramCount}`;
                values.push(params.distances.ocean.maxMeters);
            }
            if (params.distances.ocean.category) {
                paramCount++;
                sql += ` AND content->'metadata'->'distances'->'ocean'->>'category' = $${paramCount}`;
                values.push(params.distances.ocean.category);
            }
        }

        if (params.building?.floors) {
            if (params.building.floors.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'min')::int >= $${paramCount}`;
                values.push(params.building.floors.min);
            }
            if (params.building.floors.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'max')::int <= $${paramCount}`;
                values.push(params.building.floors.max);
            }
        }

        if (params.rarity?.rankRange) {
            if (params.rarity.rankRange.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int >= $${paramCount}`;
                values.push(params.rarity.rankRange.min);
            }
            if (params.rarity.rankRange.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int <= $${paramCount}`;
                values.push(params.rarity.rankRange.max);
            }
        }

        try {
            const { rows } = await this.query(sql, values);
            return rows.map(row => ({
                ...row,
                content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content
            }));
        } catch (error) {
            elizaLogger.error('Error in searchLandByMetadata:', {
                error: error instanceof Error ? error.message : String(error),
                params
            });
            throw error;
        }
    }
    async searchLandByEmbedding(
        embedding: number[],
        similarity_threshold: number = DEFAULT_MATCH_THRESHOLD
    ): Promise<LandPlotMemory[]> {
        const semanticResults = await this.searchMemoriesByEmbedding(embedding, {
            tableName: LAND_MEMORY_TYPE,
            roomId: LAND_ROOM_ID,
            agentId: LAND_AGENT_ID,
            match_threshold: similarity_threshold,
            dbTable: LAND_TABLE
        });
         return semanticResults as LandPlotMemory[];
    }

    async searchLandByCombinedCriteria(
        embedding: number[],
        metadata: Partial<LandSearchParams>,
        similarity_threshold: number = DEFAULT_MATCH_THRESHOLD

    ): Promise<LandPlotMemory[]> {
        const semanticResults = await this.searchMemoriesByEmbedding(embedding, {
            tableName: LAND_MEMORY_TYPE,
            roomId: LAND_ROOM_ID,
            agentId: LAND_AGENT_ID,
            match_threshold: similarity_threshold,
            dbTable: LAND_TABLE
        });

        console.log('searchLandByCombinedCriteria Semantic Results:', semanticResults);


        if (Object.keys(metadata).length === 0) {
            return semanticResults as LandPlotMemory[];
        }

        console.log('searchLandByCombinedCriteria Metadata:', metadata);
        const metadataResults = await this.searchLandByMetadata({
            ...metadata,
            roomId: LAND_ROOM_ID,
            agentId: LAND_AGENT_ID
        });

        const semanticIds = new Set(semanticResults.map(r => r.id));
        const filteredResults = metadataResults.filter(r => semanticIds.has(r.id));
        return filteredResults;
    }

    async getPropertiesByRarityRange(
        minRank: number,
        maxRank: number
    ): Promise<LandPlotMemory[]> {
        return this.searchLandByMetadata({
            rarity: {
                rankRange: {
                    min: minRank,
                    max: maxRank
                }
            }
        });
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/design/code/v2 land_memorysystem.ts`:

```ts
import { Memory, UUID } from "@ai16z/eliza";

// Enums for our categorical data
export enum PlotSize {
    Nano = "Nano",
    Micro = "Micro",
    Mid = "Mid",
    Mega = "Mega",
    Mammoth = "Mammoth",
    Giga = "Giga"
}

export enum ZoningType {
    Legendary = "Legendary",
    MixedUse = "Mixed Use",
    Industrial = "Industrial",
    Residential = "Residential",
    Commercial = "Commercial"
}

export enum BuildingType {
    Lowrise = "Lowrise",
    Highrise = "Highrise",
    Tall = "Tall",
    Megatall = "Megatall"
}

export enum DistanceCategory {
    Close = "Close",
    Medium = "Medium",
    Far = "Far"
}

// Interface for our property metadata
export interface LandPlotMetadata {
    neighborhood: string;
    zoning: ZoningType;
    plotSize: PlotSize;
    buildingType: BuildingType;
    distances: {
        ocean: {
            meters: number;
            category: DistanceCategory;
        };
        bay: {
            meters: number;
            category: DistanceCategory;
        };
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plot: {
        area: number;
        coordinates: {
            x: number;
            y: number;
        };
    };
    rarity: {
        rank: number;
        category: string;
    };
}

// Interface that extends Memory with our metadata
export interface LandPlotMemory extends Memory {
    id: UUID;
    content: {
        text: string;
        metadata: LandPlotMetadata;
    };
}

// Helper function to generate description from metadata
export function generateDescription(plot: LandPlotMetadata): string {
    return `${plot.plotSize} ${plot.zoning} plot in ${plot.neighborhood}. ` +
           `It is a ${plot.buildingType} building. ` +
           `Located ${plot.distances.ocean.category} from ocean and ${plot.distances.bay.category} from bay.`;
}

// Helper function to create a LandPlotMemory
export function createLandPlotMemory(
    id: UUID,
    metadata: LandPlotMetadata,
    agentId: UUID,
    roomId: UUID
): LandPlotMemory {
    return {
        id,
        agentId,
        roomId,
        userId: agentId, // Using agentId as userId for consistency
        content: {
            text: generateDescription(metadata),
            metadata
        }
    };
}

// Helper function to categorize distance
export function categorizeDistance(meters: number): DistanceCategory {
    if (meters <= 300) return DistanceCategory.Close;
    if (meters <= 700) return DistanceCategory.Medium;
    return DistanceCategory.Far;
}

// Helper function to categorize rarity
export function categorizeRarity(rank: number): string {
    if (rank <= 100) return "Ultra Premium";
    if (rank <= 500) return "Premium";
    if (rank <= 2000) return "Standard";
    if (rank <= 3000) return "Value";
    return "Entry Level";
}

// Example usage:
const plotMetadata: LandPlotMetadata = {
    neighborhood: "North Star",
    zoning: ZoningType.Residential,
    plotSize: PlotSize.Nano,
    buildingType: BuildingType.Lowrise,
    distances: {
        ocean: {
            meters: 250,
            category: DistanceCategory.Close
        },
        bay: {
            meters: 500,
            category: DistanceCategory.Medium
        }
    },
    building: {
        floors: { min: 1, max: 20 },
        height: { min: 4, max: 80 }
    },
    plot: {
        area: 1000,
        coordinates: { x: 250, y: 500 }
    },
    rarity: {
        rank: 299,
        category: "Premium"
    }
};

const landPlotMemory = createLandPlotMemory(
    "some-uuid",
    plotMetadata,
    "agent-uuid",
    "room-uuid"
);
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/design/code/land_memorysystem.ts`:

```ts
/**
 * Land Plot Memory System Design
 * 
 * This system converts land plot data into searchable memories and provides
 * a natural language interface for querying the data.
 */

interface LandPlotContent {
    text: string;          // Searchable description of the plot
    metadata: {
        rank: number;
        name: string;
        neighborhood: string;
        zoningType: string;
        plotSize: string;
        buildingSize: string;
        oceanProximity: string;
        bayProximity: string;
        floorRange: [number, number];
        plotArea: number;
        buildingHeightRange: [number, number];
        distances: {
            ocean: number;
            bay: number;
        };
    };
}

interface LandPlotMemory extends Memory {
    content: LandPlotContent;
}

/**
 * Converts a CSV row into a natural language description for embedding
 */
function generatePlotDescription(plot: any): string {
    return `${plot.Name} is a ${plot['Plot Size']} ${plot['Zoning Type']} plot in ${plot.Neighborhood}. ` +
           `It is a ${plot['Building Size']} building with ${plot['Min # of Floors']} to ${plot['Max # of Floors']} floors. ` +
           `The plot area is ${plot['Plot Area (m²)']}m² with building heights from ${plot['Min Building Height (m)']}m to ${plot['Max Building Height (m)']}m. ` +
           `Located ${plot['Distance to Ocean']} from ocean (${plot['Distance to Ocean (m)']}m) and ${plot['Distance to Bay']} from bay (${plot['Distance to Bay (m)']}m).`;
}

/**
 * System Prompt for Query Processing
 */
const LAND_QUERY_SYSTEM_PROMPT = `
You are a real estate search assistant for a futuristic city. Convert natural language queries into structured search parameters.

Given a user query, respond with a JSON object containing:
1. A natural language description for embedding matching
2. Search metadata parameters

Example Response Format:
{
    "searchText": "Large plot in Nexus neighborhood close to ocean with tall building potential",
    "metadata": {
        "neighborhood": "Nexus",
        "minPlotArea": 5000,
        "maxOceanDistance": 500,
        "minFloors": 50
    }
}

Keep the searchText natural and descriptive while being specific about requirements.
`;

/**
 * Implementation Strategy:
 * 
 * 1. Data Ingestion:
 *    - Parse CSV rows
 *    - Generate natural language descriptions
 *    - Create Memory objects with embeddings
 *    - Store in memory database
 * 
 * 2. Query Processing:
 *    - Use system prompt to convert user query to search parameters
 *    - Generate embedding for search text
 *    - Use searchMemoriesByEmbedding() with metadata filtering
 * 
 * 3. Memory Structure:
 *    - Table name: "land_plots"
 *    - Each record is a LandPlotMemory
 *    - Embedding generated from description
 *    - Metadata stored in content.metadata
 * 
 * 4. Search Flow:
 *    a. User submits natural language query
 *    b. Query processor converts to search parameters
 *    c. Generate embedding for search text
 *    d. Perform embedding search with metadata filters
 *    e. Rank and return results
 */

// Usage example:
interface SearchQuery {
    searchText: string;
    metadata: {
        neighborhood?: string;
        minPlotArea?: number;
        maxPlotArea?: number;
        minFloors?: number;
        maxFloors?: number;
        maxOceanDistance?: number;
        maxBayDistance?: number;
        zoningType?: string;
        buildingSize?: string;
    };
}

// Memory table configuration
const LAND_PLOTS_TABLE = "land_plots";
const MATCH_THRESHOLD = 0.75;
const DEFAULT_MATCH_COUNT = 20;
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/design/code/land_database_adapter.ts`:

```ts
/*
 * Land Database Adapter Design Document
 * ===================================
 * 
 * Overview
 * --------
 * The Land Database Adapter extends Eliza's PostgreSQL adapter to provide specialized 
 * functionality for managing virtual real estate data. It combines vector-based semantic 
 * search with structured metadata queries.
 * 
 * Integration with Eliza Memory System
 * ----------------------------------
 * 1. Memory Structure
 *    - Uses single table: 'land_memories'
 *    - Uses single room: 'global_land'
 *    - Uses single agent: 'land_system'
 * 
 * 2. Memory Format
 *    LandPlotMemory extends Eliza's base Memory type:
 *    {
 *      id: UUID,
 *      roomId: 'global_land',
 *      agentId: 'land_system',
 *      content: {
 *        text: string,           // Semantic description
 *        metadata: {             // Structured data
 *          neighborhood: string,
 *          zoning: ZoningType,
 *          plotSize: PlotSize,
 *          // ... other metadata
 *        }
 *      }
 *    }
 * 
 * Key Components
 * -------------
 * 1. Metadata Search
 *    - Structured queries using PostgreSQL JSON operators
 *    - Filters: neighborhood, zoning, plot size, distances, building specs, rarity
 * 
 * 2. Semantic Search
 *    - Leverages Eliza's vector search capabilities
 *    - Uses text embeddings for similarity matching
 * 
 * 3. Combined Search
 *    - Intersects results from metadata and semantic searches
 *    - Allows natural language queries with structured filters
 * 
 * Usage Patterns
 * -------------
 * 1. Creating Land Records
 *    ```typescript
 *    await landDB.createLandMemory({
 *      content: {
 *        text: "Beachfront property with ocean views...",
 *        metadata: {
 *          neighborhood: "North Shore",
 *          zoning: ZoningType.Residential
 *        }
 *      }
 *    });
 *    ```
 * 
 * 2. Searching Properties
 *    ```typescript
 *    // Metadata search
 *    const beachProperties = await landDB.searchLandByMetadata({
 *      neighborhoods: ["North Shore"],
 *      distances: { ocean: { category: DistanceCategory.Close } }
 *    });
 * 
 *    // Combined search
 *    const results = await landDB.searchLandByCombinedCriteria(
 *      queryEmbedding,
 *      { plotSizes: [PlotSize.Large] }
 *    );
 *    ```
 * 
 * Integration Steps
 * ---------------
 * 1. Initialize Database
 *    ```typescript
 *    const landDB = new LandDatabaseAdapter({
 *      host: 'localhost',
 *      database: 'land_db',
 *      // ... other pg config
 *    });
 *    await landDB.init();
 *    ```
 * 
 * 2. Connect with Memory System
 *    ```typescript
 *    import { MemorySystem } from './memories';
 * 
 *    const memorySystem = new MemorySystem({
 *      database: landDB,
 *      // ... other memory config
 *    });
 *    ```
 * 
 * 3. Use in Land System
 *    ```typescript
 *    class LandSystem {
 *      constructor(
 *        private readonly memorySystem: MemorySystem,
 *        private readonly landDB: LandDatabaseAdapter
 *      ) {}
 * 
 *      async searchProperties(query: string, filters: LandSearchParams) {
 *        const embedding = await this.memorySystem.embedText(query);
 *        return this.landDB.searchLandByCombinedCriteria(embedding, filters);
 *      }
 *    }
 *    ```
 * 
 * Performance Considerations
 * ------------------------
 * 1. Indexing
 *    - Create GiST index for vector similarity search
 *    - Create indexes on frequently queried JSON paths
 * 
 * 2. Query Optimization
 *    - Metadata filters applied before expensive vector operations
 *    - Use appropriate match thresholds for semantic search
 * 
 * Future Enhancements
 * ------------------
 * 1. Multiple Worlds Support
 *    - Add world/realm separation using roomId
 *    - Implement cross-world search capabilities
 * 
 * 2. Property Updates
 *    - Add metadata update functionality
 *    - Implement version tracking
 * 
 * 3. Spatial Search
 *    - Add coordinate-based search
 *    - Implement proximity queries
 */


import { PostgresDatabaseAdapter } from "@ai16z/adapter-postgres";
import { UUID, Memory, elizaLogger } from "@ai16z/eliza";
import { LandPlotMemory, LandPlotMetadata, DistanceCategory, PlotSize, ZoningType, BuildingType } from "./v2_land_memorysystem";

export interface LandSearchParams {
    neighborhoods?: string[];
    zoningTypes?: ZoningType[];
    plotSizes?: PlotSize[];
    buildingTypes?: BuildingType[];
    distances?: {
        ocean?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
        bay?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
    };
    building?: {
        floors?: {
            min?: number;
            max?: number;
        };
        height?: {
            min?: number;
            max?: number;
        };
    };
    rarity?: {
        rankRange?: {
            min?: number;
            max?: number;
        };
    };
}

export class LandDatabaseAdapter extends PostgresDatabaseAdapter {
    private readonly LAND_TABLE = 'land_memories';

    constructor(connectionConfig: any) {
        super(connectionConfig);
    }

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        await this.createMemory(memory, this.LAND_TABLE);
    }

    async searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]> {
        let sql = `
            SELECT * FROM memories 
            WHERE type = $1 
            AND content IS NOT NULL
        `;
        const values: any[] = [this.LAND_TABLE];
        let paramCount = 1;

        if (params.neighborhoods?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'neighborhood' = ANY($${paramCount}::text[])`;
            values.push(params.neighborhoods);
        }

        if (params.zoningTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'zoning' = ANY($${paramCount}::text[])`;
            values.push(params.zoningTypes);
        }

        if (params.plotSizes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'plotSize' = ANY($${paramCount}::text[])`;
            values.push(params.plotSizes);
        }

        if (params.distances?.ocean) {
            if (params.distances.ocean.maxMeters) {
                paramCount++;
                sql += ` AND (content->'metadata'->'distances'->'ocean'->>'meters')::int <= $${paramCount}`;
                values.push(params.distances.ocean.maxMeters);
            }
            if (params.distances.ocean.category) {
                paramCount++;
                sql += ` AND content->'metadata'->'distances'->'ocean'->>'category' = $${paramCount}`;
                values.push(params.distances.ocean.category);
            }
        }

        if (params.building?.floors) {
            if (params.building.floors.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'min')::int >= $${paramCount}`;
                values.push(params.building.floors.min);
            }
            if (params.building.floors.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'max')::int <= $${paramCount}`;
                values.push(params.building.floors.max);
            }
        }

        if (params.rarity?.rankRange) {
            if (params.rarity.rankRange.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->'rarity'->>'rank')::int >= $${paramCount}`;
                values.push(params.rarity.rankRange.min);
            }
            if (params.rarity.rankRange.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->'rarity'->>'rank')::int <= $${paramCount}`;
                values.push(params.rarity.rankRange.max);
            }
        }

        try {
            const { rows } = await this.query(sql, values);
            return rows.map(row => ({
                ...row,
                content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content
            }));
        } catch (error) {
            elizaLogger.error('Error in searchLandByMetadata:', {
                error: error instanceof Error ? error.message : String(error),
                params
            });
            throw error;
        }
    }

    async searchLandByCombinedCriteria(
        embedding: number[],
        metadata: Partial<LandSearchParams>,
        similarity_threshold: number = 0.7
    ): Promise<LandPlotMemory[]> {
        // First get semantic search results
        const semanticResults = await this.searchMemoriesByEmbedding(embedding, {
            tableName: this.LAND_TABLE,
            match_threshold: similarity_threshold
        });

        // If no metadata filters, return semantic results
        if (Object.keys(metadata).length === 0) {
            return semanticResults as LandPlotMemory[];
        }

        // Get metadata search results
        const metadataResults = await this.searchLandByMetadata(metadata);

        // Find intersection of results based on memory IDs
        const semanticIds = new Set(semanticResults.map(r => r.id));
        return metadataResults.filter(r => semanticIds.has(r.id));
    }

    async getPropertiesByRarityRange(
        minRank: number,
        maxRank: number
    ): Promise<LandPlotMemory[]> {
        return this.searchLandByMetadata({
            rarity: {
                rankRange: {
                    min: minRank,
                    max: maxRank
                }
            }
        });
    }
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/intialSearchAction.ts`:

```ts
export const startPropertySearch: Action = {
    name: "START_PROPERTY_SEARCH",
    description: "Initiates a property search session",
    similes: ["SEARCH_PROPERTIES", "FIND_PROPERTIES", "LOOK_FOR_PROPERTIES"],
    handler: async (runtime: IAgentRuntime, message: Memory, state: State) => {
        const searchManager = new PropertySearchManager(runtime);

        // Initialize search session
        // TODO:add username to sear session

        await searchManager.createSearchSession(message.userId, {
            status: "ACTIVE",
            lastQuery: null,
            results: [],
            filters: {}
        });

        return "I'm ready to help you search for properties. What kind of property are you looking for?";
    }
    // create a validator here the
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/searchContextProvider.ts`:

```ts
import { Provider } from "@codeium/core";
import { PropertySearchManager, SearchSession } from "./searchManager";
import { LandPlotMemory, LandSearchParams } from "./types";


export const propertySearchProvider: Provider = {
    get: async (runtime, message) => {
        const searchManager = new PropertySearchManager(runtime);
        const session = await searchManager.getSearchSession(message.userId);

        // TODO: get username from message
        const username = // get username from message

        if (!session || session.status === "INACTIVE") {
            return "\nThe user has not started a Wilder World property search session.\n";
        }

        let context = `Current property search session:\n`;

        if (session.lastQuery) {
            context += `Last search: "${session.lastQuery}"\n`;
        }

        if (session.results.length > 0) {
            context += `Found ${session.results.length} properties in last search.\n`;
            const neighborhoods = [...new Set(session.results.map(r => r.metadata.neighborhood))];
            context += `Properties found in: ${neighborhoods.join(", ")}\n`;

            const zoningTypes = [...new Set(session.results.map(r => r.metadata.zoning))];
            context += `Zoning types: ${zoningTypes.join(", ")}\n`;
        }

        if (Object.keys(session.filters).length > 0) {
            context += `\nActive filters:\n`;
            const filters = session.filters;

            if (filters.neighborhoods?.length) {
                context += `- Neighborhoods: ${filters.neighborhoods.join(", ")}\n`;
            }
            if (filters.zoningTypes?.length) {
                context += `- Zoning types: ${filters.zoningTypes.join(", ")}\n`;
            }
            if (filters.plotSizes?.length) {
                context += `- Plot sizes: ${filters.plotSizes.join(", ")}\n`;
            }
            if (filters.buildingTypes?.length) {
                context += `- Building types: ${filters.buildingTypes.join(", ")}\n`;
            }
            if (filters.distances?.ocean) {
                context += `- Max ocean distance: ${filters.distances.ocean.maxMeters}m\n`;
            }
            if (filters.distances?.bay) {
                context += `- Max bay distance: ${filters.distances.bay.maxMeters}m\n`;
            }
            if (filters.building?.floors) {
                const { min, max } = filters.building.floors;
                context += `- Floors: ${min || '0'}-${max || 'unlimited'}\n`;
            }
            if (filters.rarity?.rankRange) {
                const { min, max } = filters.rarity.rankRange;
                context += `- Rank range: ${min || '0'}-${max || 'unlimited'}\n`;
            }
        }

        return context;
    }
};
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/land_memory_system.ts`:

```ts
import { elizaLogger, UUID, stringToUuid, splitChunks } from "@ai16z/eliza";
import { LandPlotMemory,
    LandSearchParams,
    DEFAULT_MATCH_COUNT,
    LandKnowledgeItem,
    LandPlotMetadata,
    ZoningType,
    PlotSize,
    BuildingType,
    DistanceCategory,
    LAND_TABLE
} from "./types";
import { LAND_ROOM_ID, LAND_AGENT_ID, AGENT_ID } from "./types";
import { v4 as uuidv4 } from 'uuid';
import { ILandDataProvider } from './interfaces/ILandDataProvider';

export const LAND_QUERY_SYSTEM_PROMPT = `
You are a real estate search assistant for a futuristic city. Convert natural language queries into structured search parameters.

Given a user query, respond with a JSON object containing:
1. A natural language description for embedding matching
2. Search metadata parameters

Example Response Format:
{
    "searchText": "Large plot in Nexus neighborhood close to ocean with tall building potential",
    "metadata": {
        "neighborhood": "Nexus",
        "minPlotArea": 5000,
        "maxOceanDistance": 500,
        "minFloors": 50
    }
}

Keep the searchText natural and descriptive while being specific about requirements.
`;

export class LandMemorySystem {
    private readonly roomId: UUID = LAND_ROOM_ID;
    private readonly agentId: UUID = LAND_AGENT_ID;
    private readonly userId: UUID = AGENT_ID;

    constructor(
        private readonly dataProvider: ILandDataProvider,
        private readonly embedder: {
            embedText: (text: string) => Promise<number[]>;
        }
    ) {}

    async removeAllLandMemories(): Promise<void> {
        await this.dataProvider.removeAllLandMemories(this.roomId);
    }

    async createLandMemoryFromCSV(csvRow: any): Promise<void> {
        try {
            const metadata: LandPlotMetadata = {
                rank: parseInt(csvRow['Rank']),
                name: csvRow['Name'],
                neighborhood: csvRow['Neighborhood'],
                zoning: csvRow['Zoning Type'],
                plotSize: csvRow['Plot Size'],
                buildingType: csvRow['Building Size'],
                distances: {
                    ocean: {
                        meters: parseInt(csvRow['Distance to Ocean (m)']),
                        category: csvRow['Distance to Ocean']
                    },
                    bay: {
                        meters: parseInt(csvRow['Distance to Bay (m)']),
                        category: csvRow['Distance to Bay']
                    }
                },
                building: {
                    floors: {
                        min: parseInt(csvRow['Min # of Floors']),
                        max: parseInt(csvRow['Max # of Floors'])
                    },
                    height: {
                        min: parseFloat(csvRow['Min Building Height (m)']),
                        max: parseFloat(csvRow['Max Building Height (m)'])
                    }
                },
                plotArea: parseFloat(csvRow['Plot Area (m²)'])
            };

            await this.storeProperty(metadata);
        } catch (error) {
            elizaLogger.error('Error creating land memory:', {
                error: error instanceof Error ? error.message : String(error),
                csvRow
            });
            throw error;
        }
    }

    async searchPropertiesByParams(searchParams: Partial<LandSearchParams> = {}): Promise<LandPlotMemory[]> {
        const results = await this.dataProvider.searchLandByMetadata(searchParams);
        return results;
    }

    async mockSearchPropertiesByParams(searchParams: Partial<LandSearchParams> = {}): Promise<LandPlotMemory[]> {
        const mockProperty: LandPlotMemory = {
            id: '94e9f251-1ec7-0bde-b9cc-0fffa695eebf',
            content: {
                text: 'Oceanview Residence is a Large Residential plot in Coastal District. It is located 150m from the ocean and 2000m from the bay. The building can have between 5 and 8 floors, with heights from 15m to 24m. The plot area is 2500m².',
                metadata: {
                    name: 'Oceanview Residence',
                    rank: 1,
                    zoning: ZoningType.Residential,
                    building: {
                        floors: { max: 8, min: 5 },
                        height: { max: 24, min: 15 }
                    },
                    plotArea: 2500,
                    plotSize: PlotSize.Large, //'Large',
                    distances: {
                        bay: { meters: 2000, category: DistanceCategory.Far },
                        ocean: { meters: 150, category: DistanceCategory.Close }
                    },
                    buildingType: BuildingType.MidRise, //'MidRise',
                    neighborhood: 'Coastal District'
                }
            },
            userId: '1459b245-2171-02f6-b436-c3c2641848e5',
            agentId: '1459b245-2171-02f6-b436-c3c2641848e5',
            roomId: '1459b245-2171-02f6-b436-c3c2641848e5',
            unique: true
        };

        return [mockProperty];
    }

    /**
     * Get properties within a specific rarity range
     */
/*     async getPropertiesByRarity(
        minRank: number,
        maxRank: number,
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {
            const results = await this.dataProvider.getPropertiesByRarityRange(minRank, maxRank);
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error getting properties by rarity:', {
                error: error instanceof Error ? error.message : String(error),
                minRank,
                maxRank
            });
            throw error;
        }
    }
 */
    async storePropertyItem(
        item: LandKnowledgeItem,
        chunkSize: number = 512,
        bleed: number = 20
    ): Promise<UUID> {
        try {
            // First create the main land memory
            const mainMemory: LandPlotMemory = {
                id: item.id,
                userId: this.userId,
                agentId: this.agentId,
                roomId: this.roomId,
                content: item.content
                //embedding: await this.embedder.embedText(item.content.text)
            };
            await this.dataProvider.createLandMemory(mainMemory);
            return item.id;
        } catch (error) {
            elizaLogger.error('Error setting land knowledge:', {
                error: error instanceof Error ? error.message : String(error),
                item
            });
            throw error;
        }
    }

    async getLandKnowledgeById(id: UUID): Promise<LandKnowledgeItem | undefined> {
        const memory = await this.dataProvider.getLandMemoryById(id);
        if (!memory) return undefined;

        return {
            id: memory.id,
            content: memory.content,
 //           text: memory.text,
 //         metadata: memory.metadata
        };
    }

    async getPropertyDataById(id: UUID): Promise<LandPlotMemory | undefined> {
        const result = await this.dataProvider.getLandMemoryById(id);
        return result;
    }

    /**
     * Stores a property in the land memory system
     * @param metadata The land plot metadata to store
     * @returns The UUID of the stored property
     */
    async storeProperty(metadata: LandPlotMetadata): Promise<UUID> {
        const description = this.generatePropertyDescription(metadata);
        const knowledgeItem: LandKnowledgeItem = {
            id: stringToUuid(description+Date.now()),
            content: {
                text: description,
                metadata: metadata
            },
        };

        return await this.storePropertyItem(knowledgeItem);
    }

    /**
     * Generates a natural language description of a property from its metadata
     */
    private generatePropertyDescription(metadata: LandPlotMetadata): string {
        const description = `${metadata.name} is a ${metadata.plotSize} ${metadata.zoning} plot in ${metadata.neighborhood}. ` +
            `It is located ${metadata.distances.ocean.meters}m from the ocean and ${metadata.distances.bay.meters}m from the bay. ` +
            `The building can have between ${metadata.building.floors.min} and ${metadata.building.floors.max} floors, ` +
            `with heights from ${metadata.building.height.min}m to ${metadata.building.height.max}m. ` +
            `The plot area is ${metadata.plotArea}m².`;
        return description;
    }
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/types.ts`:

```ts
import { Memory, UUID } from "@ai16z/eliza";
import { z } from "zod";

export enum PlotSize {
    Nano = 'Nano',
    Micro = 'Micro',
    Small = 'Small',
    Medium = 'Medium',
    Large = 'Large',
    Mega = 'Mega',
    Giga = 'Giga'
}

export enum ZoningType {
    Residential = 'Residential',
    Commercial = 'Commercial',
    Industrial = 'Industrial',
    Mixed = 'Mixed',
    Special = 'Special',
    Legendary = 'Legendary'
}

export enum BuildingType {
    LowRise = 'LowRise',
    MidRise = 'MidRise',
    HighRise = 'HighRise',
    Skyscraper = 'Skyscraper',
    Megascraper = 'Megascraper'
}

export enum DistanceCategory {
    Close = 'Close',
    Medium = 'Medium',
    Far = 'Far'
}

export interface LandPlotMetadata {
    rank: number;
    name: string;
    neighborhood: string;
    zoning: ZoningType;
    plotSize: PlotSize;
    buildingType: BuildingType;
    distances: {
        ocean: {
            meters: number;
            category: DistanceCategory;
        };
        bay: {
            meters: number;
            category: DistanceCategory;
        };
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plotArea: number;
}

export interface LandPlotMemory extends Memory {
    id: UUID;
    content: {
        text: string;
        metadata: LandPlotMetadata;
        source?: UUID;  // Optional source UUID to track origin of fragments
    };
}

export interface LandSearchParams {
    roomId?: UUID;
    agentId?: UUID;
    names?: string[];
    neighborhoods?: string[];
    zoningTypes?: ZoningType[];
    plotSizes?: PlotSize[];
    buildingTypes?: BuildingType[];
    distances?: {
        ocean?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
        bay?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
    };
    building?: {
        floors?: {
            min?: number;
            max?: number;
        };
        height?: {
            min?: number;
            max?: number;
        };
    };
    rarity?: {
        rankRange?: {
            min?: number;
            max?: number;
        };
    };
}

export interface LandKnowledgeItem {
    id: UUID;
    content: {
        text: string;
        metadata: any;
    };
}

// Zod schema for search metadata
export const SearchMetadataSchema = z.object({
    searchText: z.string(),
    metadata: z.object({
        neighborhood: z.array(z.string()).optional(),
        zoningTypes: z.array(z.nativeEnum(ZoningType)).optional(),
        plotSizes: z.array(z.nativeEnum(PlotSize)).optional(),
        buildingTypes: z.array(z.nativeEnum(BuildingType)).optional(),
        distances: z.object({
            ocean: z.object({
                maxMeters: z.number().optional(),
                category: z.nativeEnum(DistanceCategory).optional()
            }).optional(),
            bay: z.object({
                maxMeters: z.number().optional(),
                category: z.nativeEnum(DistanceCategory).optional()
            }).optional()
        }).optional(),
        building: z.object({
            floors: z.object({
                min: z.number().optional(),
                max: z.number().optional()
            }).optional(),
            height: z.object({
                min: z.number().optional(),
                max: z.number().optional()
            }).optional()
        }).optional(),
        rarity: z.object({
            rankRange: z.object({
                min: z.number().optional(),
                max: z.number().optional()
            }).optional()
        }).optional()
    })
});

export type SearchMetadata = z.infer<typeof SearchMetadataSchema>;

// Constants
export const AGENT_ID: `${string}-${string}-${string}-${string}-${string}` = '1459b245-2171-02f6-b436-c3c2641848e5';
export const LAND_TABLE = 'land_table';
export const LAND_ROOM_ID = AGENT_ID;
export const LAND_AGENT_ID = AGENT_ID;
export const LAND_USER_ID = AGENT_ID;
export const DEFAULT_MATCH_THRESHOLD = 0.4;
export const DEFAULT_MATCH_COUNT = 20;

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/interfaces/ILandDataProvider.ts`:

```ts
import { LandPlotMemory, LandSearchParams } from '../types';
import { UUID } from '@ai16z/eliza';

export interface ILandDataProvider {
    createLandMemory(memory: LandPlotMemory): Promise<void>;
    getLandMemoryById(id: string): Promise<LandPlotMemory>;
    getLandMemories(roomId: UUID): Promise<LandPlotMemory[]>;
    removeLandMemory(id: string): Promise<void>;
    removeAllLandMemories(roomId: UUID): Promise<void>;
    searchLandMemories(roomId: UUID, query: string, params?: Partial<LandSearchParams>): Promise<LandPlotMemory[]>;
    updateLandMemory(memory: LandPlotMemory): Promise<void>;
    searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]>;
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/runtime-property-database2.test.ts`:

```ts
import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { LandDatabaseAdapter } from "../land_database_adapter";
import { LandMemorySystem } from "../land_memory_system";
import {
    LandPlotMemory,
    LandPlotMetadata,
    ZoningType,
    PlotSize,
    BuildingType,
    DistanceCategory,
    LAND_TABLE,
    LAND_ROOM_ID,
    LAND_AGENT_ID,
    LandSearchParams,
    LandKnowledgeItem
} from "../types";
import { stringToUuid, ModelProviderName, MemoryManager, embed } from "@ai16z/eliza";
import { printLandMemory } from "../logging";

describe('Land Plot Database Operations', () => {
    let runtime: any;
    let db: LandDatabaseAdapter;
    let memorySystem: LandMemorySystem;
    let idCounter = 0;
    const generateUniqueId = (prefix: string) => {
        idCounter++;
        return stringToUuid(`${prefix}-${idCounter}`);
    };

    beforeAll(async () => {
        // Initialize database
        db = new LandDatabaseAdapter({
            connectionString: process.env.POSTGRES_URL || 'postgresql://postgres:postgres@localhost:5432/test',
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
        });

        await db.init();

        // Create runtime with real database adapter
        runtime = {
            agentId: LAND_AGENT_ID,
            serverUrl: 'http://localhost:3000',
            databaseAdapter: db,
            token: process.env.OPENAI_API_KEY,
            modelProvider: 'openai' as ModelProviderName,
            character: {
                modelProvider: 'openai',
                modelEndpointOverride: process.env.OPENAI_API_ENDPOINT,
            },
            messageManager: {
                getCachedEmbeddings: async () => [],
            },
            memoryManager: new MemoryManager({ tableName: 'memories', runtime }),
            documentsManager: new MemoryManager({ tableName: 'documents', runtime }),
            knowledgeManager: new MemoryManager({ tableName: 'knowledge', runtime }),
            getCachedEmbeddings: async () => {
                // Return a properly sized embedding array
                return new Float32Array(1536).fill(0.1);
            },
        };

        const embedder = {
            embedText: async (text: string) => embed(runtime, text)
        };

        // Initialize memory system with real embedder
        memorySystem = new LandMemorySystem(db, embedder);

        // Clear any existing data before all tests
        await memorySystem.removeAllLandMemories();

    });

    beforeEach(async () => {
        // Reset ID counter
        idCounter = 0;
        // Clear database
        //await db.removeAllLandMemories(LAND_ROOM_ID);
    });

    afterEach(async () => {
        // Clean up after each test
        //await db.removeAllLandMemories(LAND_ROOM_ID);
    });

    afterAll(async () => {
        //await memorySystem.removeAllLandMemories();
        await db.close();
    });

    const landMetadata1: LandPlotMetadata = {
        rank: 1,
        name: 'Oceanview Residence',
        neighborhood: 'Coastal District',
        zoning: ZoningType.Residential,
        plotSize: PlotSize.Large,
        buildingType: BuildingType.MidRise,
        distances: {
            ocean: {
                meters: 150,
                category: DistanceCategory.Close
            },
            bay: {
                meters: 2000,
                category: DistanceCategory.Far
            }
        },
        building: {
            floors: { min: 5, max: 8 },
            height: { min: 15, max: 24 }
        },
        plotArea: 2500,
    };


    describe('Land Knowledge Operations', () => {
        test('should store and retrieve land knowledge with storeProperty()', async () => {

            const id = await memorySystem.storeProperty(landMetadata1);

            // Store the knowledge and get the ID
            expect(id).toBeDefined();

            // Retrieve the knowledge by ID
            const retrievedKnowledge = await memorySystem.getLandKnowledgeById(id);
            expect(retrievedKnowledge).toBeDefined();
            expect(retrievedKnowledge?.content.text).toBeDefined();
            expect(retrievedKnowledge?.content.metadata).toEqual(landMetadata1);
            await memorySystem.removeAllLandMemories();
        });
    });

    describe('Land Plot Creation', () => {
        test('should create valid land plot memory', async () => {

            await memorySystem.storeProperty(landMetadata1);

            // Verify creation by searching for the property
            const searchParams = {
                names: [landMetadata1.name]
            }
            const results = await memorySystem.searchPropertiesByParams(searchParams);

            expect(results.length).toBeGreaterThan(0);

            const result = results[0];
            expect(result.content.metadata.name).toBe(landMetadata1.name);
            expect(result.content.metadata.plotSize).toBe(landMetadata1.plotSize);
            expect(result.content.metadata.zoning).toBe(landMetadata1.zoning);
        }, 10000);
    });


    describe('Land Plot Search', () => {
        test('should find plots by neighborhood', async () => {
            const searchParams = {
                neighborhoods: ['Coastal District']
            };

            const results = await memorySystem.searchPropertiesByParams(searchParams);

            expect(results.length).toBeGreaterThan(0);
            expect(results[0].content.metadata.neighborhood).toBe('Coastal District');
        });

        test('should find plots by neighborhood and plot size', async () => {
            const searchParams = {
                neighborhoods: ['Coastal District'],
                plotSizes: [PlotSize.Large],
           };

            const results = await memorySystem.searchPropertiesByParams(searchParams);

            expect(results.length).toBeGreaterThan(0);
            results.forEach(result => {
                console.log("Neighborhood + Plot Size test" ,
                    result.content.metadata.neighborhood,
                    result.content.metadata.plotSize);

                console.log("-- result --");
                console.log(result);
                console.log("-- building --")
                console.log(result.content.metadata.building);
                console.log("-- distances --");
                console.log(result.content.metadata.distances);


                expect(result.content.metadata.neighborhood).toBe('Coastal District');
                expect(result.content.metadata.plotSize).toBe(PlotSize.Large);
                //expect(result.content.metadata.distances.ocean.meters).toBeLessThanOrEqual(200);
            });
        });

        test('should find plots by distance to ocean', async () => {
            const searchParams = {
                distances: {
                    ocean: {
                        maxMeters: 200,
                        category: DistanceCategory.Close
                    }
                }
            };

            const results = await memorySystem.searchPropertiesByParams(searchParams);

            expect(results.length).toBeGreaterThan(0);
            results.forEach(result => {
                console.log("Distance to Ocean test\n",
                    "distance to Ocean", result.content.metadata.distances.ocean.meters,
                    "\ndistance category", result.content.metadata.distances.ocean.category);
                expect(result.content.metadata.distances.ocean.meters).toBeLessThanOrEqual(200);
            });
        });

        /*         test('should find plots by semantic search', async () => {
            const testMetadata = landMetadata1;

            const query = `${testMetadata.name} is a ${testMetadata.plotSize} ${testMetadata.zoning} plot in ${testMetadata.neighborhood}. `

            const testMetadataParams: Partial<LandSearchParams> = {
                neighborhoods: [testMetadata.neighborhood],
                zoningTypes: [testMetadata.zoning],
                plotSizes: [testMetadata.plotSize],
                buildingTypes: [testMetadata.buildingType]
            };

            console.log('Query:', query);
            console.log('Metadata Params:', testMetadataParams);

            const results = await memorySystem.searchProperties(query,testMetadataParams);

            expect(results.length).toBeGreaterThan(0);
            results.forEach(result => {
                expect(result.content.metadata.plotSize).toBe(PlotSize.Large);
                expect(result.content.metadata.zoning).toBe(ZoningType.Residential);
                expect(result.content.metadata.distances.ocean.category).toBe(DistanceCategory.Close);
            });
        }); */
    });




});
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/searchManager.ts`:

```ts
import { LandMemorySystem } from './land_memory_system';
import { LandSearchParams, LandPlotMemory, SearchMetadata, SearchMetadataSchema } from './types';
import { IAgentRuntime } from '@ai16z/eliza';
import { PostgresLandDataProvider } from './adapters/PostgresLandDataProvider';
import { LandDatabaseAdapter } from './land_database_adapter';

interface PropertyResult {
    rank: number;
    name: string;
    neighborhood: string;
    zoningType: string;
    plotSize: string;
    buildingSize: string;
    distances: {
        ocean: number;
        bay: number;
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plotArea: number;
}

const sampleProperties: PropertyResult[] = [
    {
        rank: 44,
        name: "SM-577",
        neighborhood: "Space Mind",
        zoningType: "Mixed Use",
        plotSize: "Mega",
        buildingSize: "Highrise",
        distances: { ocean: 830, bay: 742 },
        building: {
            floors: { min: 44, max: 55 },
            height: { min: 222, max: 277 }
        },
        plotArea: 7169
    },
    {
        rank: 45,
        name: "HH-878",
        neighborhood: "Haven Heights",
        zoningType: "Industrial",
        plotSize: "Giga",
        buildingSize: "Lowrise",
        distances: { ocean: 383, bay: 673 },
        building: {
            floors: { min: 7, max: 9 },
            height: { min: 36, max: 45 }
        },
        plotArea: 9363
    },
    {
        rank: 47,
        name: "DZ-225",
        neighborhood: "District ZERO",
        zoningType: "Industrial",
        plotSize: "Giga",
        buildingSize: "Lowrise",
        distances: { ocean: 1006, bay: 1090 },
        building: {
            floors: { min: 6, max: 8 },
            height: { min: 32, max: 40 }
        },
        plotArea: 10095
    },
    {
        rank: 51,
        name: "NS-931",
        neighborhood: "North Star",
        zoningType: "Mixed Use",
        plotSize: "Macro",
        buildingSize: "Highrise",
        distances: { ocean: 453, bay: 766 },
        building: {
            floors: { min: 37, max: 46 },
            height: { min: 188, max: 234 }
        },
        plotArea: 5323
    },
    {
        rank: 54,
        name: "FL-90",
        neighborhood: "Flashing Lights",
        zoningType: "Mixed Use",
        plotSize: "Mid",
        buildingSize: "Highrise",
        distances: { ocean: 2536, bay: 302 },
        building: {
            floors: { min: 42, max: 52 },
            height: { min: 212, max: 264 }
        },
        plotArea: 4603
    },
    {
        rank: 56,
        name: "FL-99",
        neighborhood: "Flashing Lights",
        zoningType: "Mixed Use",
        plotSize: "Mid",
        buildingSize: "Highrise",
        distances: { ocean: 889, bay: 1077 },
        building: {
            floors: { min: 36, max: 45 },
            height: { min: 181, max: 226 }
        },
        plotArea: 4081
    },
    {
        rank: 59,
        name: "FL-133",
        neighborhood: "Flashing Lights",
        zoningType: "Mixed Use",
        plotSize: "Mammoth",
        buildingSize: "Lowrise",
        distances: { ocean: 2709, bay: 361 },
        building: {
            floors: { min: 16, max: 19 },
            height: { min: 80, max: 99 }
        },
        plotArea: 7393
    }
];

export interface SearchSession {
    status: "ACTIVE" | "INACTIVE";
    lastQuery: string | null;
    results: LandPlotMemory[];
    filters: Partial<LandSearchParams>;
}

export class PropertySearchManager {
    private memorySystem: LandMemorySystem;

    constructor(private runtime: IAgentRuntime) {
        // Create database adapter and wrap it in our data provider
        const dbAdapter = new LandDatabaseAdapter(runtime.databaseAdapter.connectionConfig);
        const landDataProvider = new PostgresLandDataProvider(dbAdapter);

        // Create embedder from runtime
        const embedder = {
            embedText: async (text: string) => {
                return await runtime.embedder.embedText(text);
            }
        };

        // Initialize memory system with the data provider
        this.memorySystem = new LandMemorySystem(landDataProvider, embedder);
    }

    async createSearchSession(userId: string, initialState: SearchSession) {
        await this.runtime.setMemory(userId + "_property_search", initialState);
    }

    async getSearchSession(userId: string): Promise<SearchSession | null> {
        return await this.runtime.getMemory(userId + "_property_search");
    }

    async updateSearchResults(userId: string, results: LandPlotMemory[]) {
        const session = await this.getSearchSession(userId);
        if (!session) return;

        session.results = results;
        await this.runtime.setMemory(userId + "_property_search", session);
    }

    async executeSearch(searchMetadata: SearchMetadata): Promise<LandPlotMemory[]> {
        // Validate search metadata using Zod schema
        const validatedMetadata = SearchMetadataSchema.parse(searchMetadata);

        // Convert SearchMetadata to LandSearchParams
        const searchParams: Partial<LandSearchParams> = {
            neighborhoods: validatedMetadata.metadata.neighborhood,
            zoningTypes: validatedMetadata.metadata.zoningTypes,
            plotSizes: validatedMetadata.metadata.plotSizes,
            buildingTypes: validatedMetadata.metadata.buildingTypes,
            distances: {
                ocean: validatedMetadata.metadata.distances?.ocean ? {
                    maxMeters: validatedMetadata.metadata.distances.ocean.maxMeters,
                    category: validatedMetadata.metadata.distances.ocean.category
                } : undefined,
                bay: validatedMetadata.metadata.distances?.bay ? {
                    maxMeters: validatedMetadata.metadata.distances.bay.maxMeters,
                    category: validatedMetadata.metadata.distances.bay.category
                } : undefined
            },
            building: {
                floors: validatedMetadata.metadata.building?.floors,
                height: validatedMetadata.metadata.building?.height
            },
            rarity: {
                rankRange: validatedMetadata.metadata.rarity?.rankRange
            }
        };

        // Use the memory system's search functionality
        return await this.memorySystem.mockSearchPropertiesByParams(searchParams);
        // return await this.memorySystem.searchPropertiesByParams(searchParams);
    }
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/adapters/PostgresLandDataProvider.ts`:

```ts
import { LandDatabaseAdapter } from '../land_database_adapter';
import { ILandDataProvider } from '../interfaces/ILandDataProvider';
import { LandPlotMemory, LandSearchParams } from '../types';
import { UUID } from '@ai16z/eliza';

export class PostgresLandDataProvider implements ILandDataProvider {
    constructor(private readonly dbAdapter: LandDatabaseAdapter) {}

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        await this.dbAdapter.createLandMemory(memory);
    }

    async getLandMemoryById(id: string): Promise<LandPlotMemory> {
        return await this.dbAdapter.getLandMemoryById(id);
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
        return await this.dbAdapter.getLandMemories(roomId);
    }

    async removeLandMemory(id: string): Promise<void> {
        await this.dbAdapter.removeLandMemory(id);
    }

    async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.dbAdapter.removeAllLandMemories(roomId);
    }

    async searchLandMemories(roomId: UUID, query: string, params?: Partial<LandSearchParams>): Promise<LandPlotMemory[]> {
        return await this.dbAdapter.searchLandMemories(roomId, query, params);
    }

    async updateLandMemory(memory: LandPlotMemory): Promise<void> {
        await this.dbAdapter.updateLandMemory(memory);
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/searchProcessingAction.ts`:

```ts
import { Action, IAgentRuntime, Memory, State,
    ModelClass,
    composeContext,
} from "@ai16z/eliza";

import { PropertySearchManager } from "./searchManager";
import { generateObjectV2 } from "@ai16z/eliza";
import { LAND_QUERY_SYSTEM_PROMPT } from "./land_memory_system";
import { LandPlotMemory, SearchMetadataSchema } from "./types";
import { Z } from "vitest/dist/chunks/reporters.D7Jzd9GS.js";
import { z } from "zod";

export const processPropertySearch: Action = {
    name: "PROCESS_PROPERTY_SEARCH",
    similes: ["PROCESS_PROPERTY_SEARCH"],
    description: "Processes a property search and returns results",
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "give me all properties in space mind with a view of the ocean",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Searching for space mind properties:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "What are all legendary plots close to the bay",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Searching for legendary plots close to the bay:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
    ],
    handler: async (runtime: IAgentRuntime, message: Memory, state: State | undefined) => {
        if (!state) {
            throw new Error('State is required for property search processing');
        }
        const searchManager = new PropertySearchManager(runtime);

        const TEST_LAND_QUERY_SYSTEM_PROMPT = `
You are helping to test a memory retrieval system. For test purposes,
Please generate this specific JSON response for the query given.
Only respond with the JSON response. You should insert the original USER PROMPT
into the JSON reponse in {user supplied query}.  for the metadata, just
use the values provided below.  In this way we test the memory retrieval system.
HERE IS THE JSON RESPONSE template below.  Only responsd with the JSON reponse.
{
    "searchText": "{user supplied query}",
    "metadata": {
        "neighborhood": ["Flashing Lights"],
        "maxDistance": {
            "ocean": 300,
            "bay": null
        }
    }
}
USER PROMPT:
{{currentMessage}}
`
        const context = composeContext({
            state,
            template: LAND_QUERY_SYSTEM_PROMPT,
        });

        console.log("Generated context:", context);

        // Generate search metadata using LLM
/*         const searchMetadata = (await generateObjectV2({
            runtime,
            context,
            modelClass: ModelClass.LARGE,
            schema: SearchMetadataSchema,
        })) as z.infer<typeof SearchMetadataSchema>;
 */

        const searchMetadata = {
            searchText: message.content.text,
            metadata: {
                neighborhood: ["Flashing Lights"],
                maxDistance: {
                    ocean: 300,
                    bay: null
                }
            }
        }

        console.log("Generated search metadata:", searchMetadata);

        // Execute search
        const results = await searchManager.executeSearch(searchMetadata);

        console.log("Search results:", results);

        // Store results in session
        await searchManager.updateSearchResults(message.userId, results);

        // Format response
        return formatSearchResults(results);
    },
    validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
        const searchManager = new PropertySearchManager(runtime);
        const session = await searchManager.getSearchSession(message.userId);
        return !!session && session.status === "ACTIVE";
    }
};

function formatSearchResults(landMemories: LandPlotMemory[]): string {
    if (landMemories.length === 0) {
        return "I couldn't find any properties matching your criteria. Would you like to try a different search?";
    }

    let response = `I found ${landMemories.length} properties matching your criteria:\n\n`;
    landMemories.forEach(property => {
        const metadata = property.content.metadata;
        response += `${metadata.name} in ${metadata.neighborhood}:\n`;
        response += `- ${metadata.buildingType} ${metadata.zoning} building\n`;
        response += `- Plot size: ${metadata.plotSize} (${metadata.plotArea}m²)\n`;
        response += `- Floors: ${metadata.building.floors.min}-${metadata.building.floors.max}\n`;
        response += `- Ocean: ${metadata.distances.ocean.meters}m (${metadata.distances.ocean.category})\n`;
        response += `- Bay: ${metadata.distances.bay.meters}m (${metadata.distances.bay.category})\n\n`;
    });

    return response;
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/unreal/property-search-design/land_database_adapter.ts`:

```ts
import { PostgresDatabaseAdapter } from "@ai16z/adapter-postgres";
import { elizaLogger, UUID } from "@ai16z/eliza";
import {
    LandPlotMemory,
    LandSearchParams,
    LAND_TABLE,
    LAND_ROOM_ID,
    LAND_AGENT_ID,
    DEFAULT_MATCH_THRESHOLD
} from "./types";

const LAND_MEMORY_TYPE = 'land_plot';

export class LandDatabaseAdapter extends PostgresDatabaseAdapter {
    constructor(connectionConfig: any) {
        super(connectionConfig);
    }

    async init(): Promise<void> {
        await super.init();
        // Add any additional initialization specific to LandDatabaseAdapter if needed
    }

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        console.log("Creating land memory with :", memory.embedding);
        await this.createMemory(memory, LAND_MEMORY_TYPE, true, LAND_TABLE);
    }

    async getLandMemoryById(id: UUID): Promise<LandPlotMemory | undefined> {
        const memory = await super.getMemoryById(id, LAND_MEMORY_TYPE, LAND_TABLE);
        if (!memory) return undefined;
        return memory as LandPlotMemory;
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
        const memories = await this.getMemories({
            roomId,
            tableName: LAND_MEMORY_TYPE,
            dbTable: LAND_TABLE
        });
        return memories as LandPlotMemory[];
    }

    async removeLandMemory(memoryId: UUID): Promise<void> {
        await this.removeMemory(memoryId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.removeAllMemories(roomId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]> {
        let sql = `
            SELECT * FROM ${LAND_TABLE}
            WHERE type = $1
            AND content IS NOT NULL
        `;
        const values: any[] = [LAND_MEMORY_TYPE];
        let paramCount = 1;

        if (params.neighborhoods?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'neighborhood' = ANY($${paramCount}::text[])`;
            values.push(params.neighborhoods);
        }

        if (params.zoningTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'zoning' = ANY($${paramCount}::text[])`;
            values.push(params.zoningTypes);
        }

        if (params.plotSizes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'plotSize' = ANY($${paramCount}::text[])`;
            values.push(params.plotSizes);
        }

        if (params.buildingTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'buildingType' = ANY($${paramCount}::text[])`;
            values.push(params.buildingTypes);
        }

        if (params.distances?.ocean) {
            if (params.distances.ocean.maxMeters) {
                paramCount++;
                sql += ` AND (content->'metadata'->'distances'->'ocean'->>'meters')::int <= $${paramCount}`;
                values.push(params.distances.ocean.maxMeters);
            }
            if (params.distances.ocean.category) {
                paramCount++;
                sql += ` AND content->'metadata'->'distances'->'ocean'->>'category' = $${paramCount}`;
                values.push(params.distances.ocean.category);
            }
        }

        if (params.building?.floors) {
            if (params.building.floors.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'min')::int >= $${paramCount}`;
                values.push(params.building.floors.min);
            }
            if (params.building.floors.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'max')::int <= $${paramCount}`;
                values.push(params.building.floors.max);
            }
        }

        if (params.rarity?.rankRange) {
            if (params.rarity.rankRange.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int >= $${paramCount}`;
                values.push(params.rarity.rankRange.min);
            }
            if (params.rarity.rankRange.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int <= $${paramCount}`;
                values.push(params.rarity.rankRange.max);
            }
        }

        try {
            const { rows } = await this.query(sql, values);
            return rows.map(row => ({
                ...row,
                content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content
            }));
        } catch (error) {
            elizaLogger.error('Error in searchLandByMetadata:', {
                error: error instanceof Error ? error.message : String(error),
                params
            });
            throw error;
        }
    }


    async getPropertiesByRarityRange(
        minRank: number,
        maxRank: number
    ): Promise<LandPlotMemory[]> {
        return this.searchLandByMetadata({
            rarity: {
                rankRange: {
                    min: minRank,
                    max: maxRank
                }
            }
        });
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/vitest.config.ts`:

```ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['dotenv/config'],
  },
})

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/utils.ts`:

```ts
import { PropertyData } from './types';

interface CSVOptions {
    hasHeaders?: boolean;
    delimiter?: string;
}

/**
 * Parse CSV content into PropertyData objects
 */
export function parseCSV(content: string, options: CSVOptions = {}): PropertyData[] {
    const {
        hasHeaders = true,
        delimiter = ','
    } = options;

    // Split into lines
    const lines = content.trim().split('\n');
    if (lines.length === 0) return [];

    // Handle headers
    let startIndex = 0;
    let headers: string[] = [];
    if (hasHeaders) {
        headers = lines[0].split(delimiter).map(h => h.trim());
        startIndex = 1;
    }

    // Parse data lines
    return lines.slice(startIndex).map((line, index) => {
        const values = line.split(delimiter).map(v => v.trim());
        
        // Create property object
        const property: Partial<PropertyData> = {
            id: values[0] || String(index),
            name: values[1] || `Property ${index}`,
        };

        // Map remaining values to fields
        if (hasHeaders) {
            headers.forEach((header, i) => {
                if (i > 1) { // Skip id and name which we already handled
                    const value = values[i];
                    if (value !== undefined && value !== '') {
                        (property as any)[header] = parseValue(value);
                    }
                }
            });
        }

        return property as PropertyData;
    });
}

/**
 * Parse string value into appropriate type
 */
function parseValue(value: string): any {
    // Try parsing as number
    if (!isNaN(Number(value))) {
        return Number(value);
    }

    // Try parsing as boolean
    if (value.toLowerCase() === 'true') return true;
    if (value.toLowerCase() === 'false') return false;

    // Try parsing as date
    const date = new Date(value);
    if (!isNaN(date.getTime())) return date;

    // Return as string
    return value;
}

/**
 * Calculate cosine similarity between two vectors
 */
export function cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) {
        throw new Error('Vector dimensions must match');
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
    }

    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);

    if (normA === 0 || normB === 0) return 0;
    return dotProduct / (normA * normB);
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/index.ts`:

```ts
import { Plugin, IAgentRuntime, Memory, State, ServiceType, elizaLogger } from '@ai16z/eliza';
import { PropertyStorage } from './storage';
import { MemoryPropertyStorage } from './storage/memory-storage';
import { PropertyStorageService } from './services';
import { Action } from '@ai16z/eliza';

const searchPropertiesAction: Action = {
    name: 'search-properties',
    description: 'Search for properties using natural language',
    similes: [
        'find properties',
        'search properties',
        'lookup properties',
        'list properties',
        'search properties for matches'
    ],
    examples: [[
        {
            user: "user",
            content: {
                text: "Search properties for sale",
                action: "search-properties"
            }
        }
    ]],
    handler: async (
        runtime: IAgentRuntime,
        message: Memory,
        state?: State,
        options?: { [key: string]: unknown }
    ): Promise<unknown> => {
        elizaLogger.info('search-properties handler starting', {
            messageText: message?.content?.text,
            hasState: !!state,
            hasOptions: !!options,
            runtimeType: runtime?.constructor?.name
        });

        if (!runtime) {
            elizaLogger.error('Runtime not initialized');
            throw new Error('Runtime not initialized');
        }

        // Initialize the service with runtime
        try {
            await service.initialize(runtime);
        } catch (error) {
            elizaLogger.error('Failed to initialize service:', error);
            throw error;
        }

        // Extract the search query from the message text
        const text = message.content?.text || '';
        elizaLogger.info('Processing search query:', { originalText: text });

        let query = text;
        if (text.includes('listings for')) {
            query = text.split('listings for')[1].trim();
        } else if (text.includes('properties')) {
            query = text.split('properties')[1]?.trim() || text;
        }

        elizaLogger.info('Extracted search query:', { query });

        // Use the storage's search interface with the query
        const results = await service.searchByFilters({
            operator: 'OR',
            filters: [
                {
                    field: 'description',
                    value: query.toLowerCase(),
                    operator: '$in'
                },
                {
                    field: 'name',
                    value: query.toLowerCase(),
                    operator: '$in'
                },
                {
                    field: 'neighborhood',
                    value: query.toLowerCase(),
                    operator: '$in'
                }
            ]
        });

        elizaLogger.info('Search results:', results);

        return {
            userId: runtime.agentId,
            agentId: runtime.agentId,
            roomId: message.roomId,
            content: {
                text: `Here are the properties matching "${query}":\n\n${
                    results.length > 0
                        ? results.map(r => r.property
                            ? `- ${r.property.name}: ${r.property.description}`
                            : `- Unknown property`
                          ).join('\n')
                        : 'No matching properties found.'
                }`,
                action: 'search-properties'
            }
        };
    },
    validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
        return !!runtime && !!message;
    }
} as Action;

// Create the plugin instance
const storage = new MemoryPropertyStorage();
const service = new PropertyStorageService(storage);

// Export the plugin
export const spreadsheetPlugin: Plugin = {
    name: "spreadsheet",
    description: "Plugin for managing property data in a spreadsheet format",
    actions: [searchPropertiesAction],
    services: [service],
    evaluators: [],
    providers: []
};
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/services/index.ts`:

```ts
import { Service, ServiceType, AgentRuntime, elizaLogger } from '@ai16z/eliza';
import { PropertyStorage } from '../storage';
import { MemoryPropertyStorage } from '../storage/memory-storage';
import { FilterGroup, SearchOptions, SearchResult } from '../types';
import { StorageError, StorageErrorCode } from '../errors';

export class PropertyStorageService implements Service {
    readonly type = ServiceType.PROPERTY_STORAGE;
    private runtime: AgentRuntime | null = null;

    constructor(
        private storage: PropertyStorage
    ) {
        elizaLogger.debug('PropertyStorageService: Constructor called');
    }

    get serviceType(): ServiceType {
        return ServiceType.PROPERTY_STORAGE;
    }

    async initialize(runtime: AgentRuntime): Promise<void> {
        elizaLogger.debug('PropertyStorageService: Initializing with runtime', {
            hasRuntime: !!runtime,
            runtimeType: runtime?.constructor?.name,
            agentId: runtime?.agentId
        });
        this.runtime = runtime;
        await this.storage.initialize(runtime);
        elizaLogger.debug('PropertyStorageService: Initialization complete');
    }

    async searchByFilters(filters: FilterGroup): Promise<SearchResult[]> {
        elizaLogger.debug('PropertyStorageService.searchByFilters called', {
            hasRuntime: !!this.runtime,
            hasStorage: !!this.storage,
            operator: filters.operator,
            filterCount: filters.filters?.length,
            filterFields: filters.filters?.map(f => typeof f === 'object' && 'field' in f ? f.field : 'group')
        });

        if (!this.runtime) {
            elizaLogger.error('PropertyStorageService: Runtime not initialized');
            throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Runtime not initialized');
        }

        elizaLogger.info('PropertyStorageService.searchByFilters called with:', {
            operator: filters.operator,
            filterCount: filters.filters?.length,
            filterFields: filters.filters?.map(f => typeof f === 'object' && 'field' in f ? f.field : 'group')
        });

        if (!this.storage) {
            throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Storage not initialized');
        }

        try {
            const results = await this.storage.searchByFilters(filters);
            elizaLogger.info('PropertyStorageService search results:', {
                hasResults: !!results,
                resultsType: results ? typeof results : 'undefined',
                isArray: Array.isArray(results),
                count: results?.length || 0,
                results: results ? results.map(r => ({ id: r?.property?.id, name: r?.property?.name })) : []
            });
            if (!results) {
                throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Search returned no results');
            }
            return results;
        } catch (error) {
            elizaLogger.error('Error in PropertyStorageService.searchByFilters:', error);
            throw error;
        }
    }

    async searchByVector(vector: number[], options: SearchOptions): Promise<SearchResult[]> {
        if (!this.storage) {
            throw new Error('PropertyStorageService not initialized');
        }
        return this.storage.searchByVector(vector, options);
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/types.ts`:

```ts
/**
 * Core property data interface
 */
export interface PropertyData {
    id: string;
    name: string;
    neighborhood: string;
    zoningType: string;
    plotSize: string;
    buildingSize: string;
    maxFloors: number;
    minFloors: number;
    plotArea: number;
    maxBuildingHeight: number;
    minBuildingHeight: number;
    oceanDistanceMeters: number;
    bayDistanceMeters: number;
    description: string;
    nft?: NFTMetadata;
    market?: MarketStatus;
}

/**
 * NFT-specific metadata
 */
export interface NFTMetadata {
    tokenId: string;
    contractAddress: string;
    blockchain: 'ethereum' | 'polygon';
    lastSalePrice?: number;
    lastSaleDate?: Date;
}

/**
 * Real-time market status
 */
export interface MarketStatus {
    isListed: boolean;
    currentPrice?: number;
    currency?: string;
    marketplace: 'opensea' | 'other';
    listingUrl?: string;
    lastUpdated: Date;
}

/**
 * Options for search operations
 */
export interface SearchOptions {
    limit: number;
    threshold?: number;
    includeMetadata?: boolean;
    sortBy?: 'similarity' | 'price' | 'date';
}

/**
 * Search result with similarity score
 */
export interface SearchResult {
    id: string;
    property?: PropertyData;
    similarity: number;
    matchedFilters?: string[];
}

/**
 * Filter types and operators
 */
export type FilterOperator = 
    | '$eq' | '$ne'
    | '$gt' | '$gte'
    | '$lt' | '$lte'
    | '$in' | '$nin'
    | '$exists'
    | '$near';

/**
 * Single metadata filter
 */
export interface MetadataFilter {
    field: string;
    operator: FilterOperator;
    value: any;
}

/**
 * Group of filters with logical operator
 */
export interface FilterGroup {
    operator: 'AND' | 'OR';
    filters: (MetadataFilter | FilterGroup)[];
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/storage/memory-storage.ts`:

```ts
import { PropertyData, SearchOptions, SearchResult, FilterGroup, MetadataFilter } from '../types';
import { StorageError, StorageErrorCode } from '../errors';
import { BasePropertyStorage } from '../storage';
import { knowledge, elizaLogger, AgentRuntime, Memory, KnowledgeItem, stringToUuid } from '@ai16z/eliza';

/**
 * In-memory implementation of PropertyStorage
 */
export class MemoryPropertyStorage extends BasePropertyStorage {
    private properties: Map<string, PropertyData> = new Map();
    private nextId: number = 1;
    private runtime: AgentRuntime | null = null;

    constructor() {
        super();
        elizaLogger.info('MemoryPropertyStorage: Constructor called');
    }

    initialize(runtime: AgentRuntime) {
        elizaLogger.info('MemoryPropertyStorage: Initializing with runtime', {
            hasRuntime: !!runtime,
            runtimeType: runtime?.constructor?.name,
            agentId: runtime?.agentId
        });
        this.runtime = runtime;
    }

    async addProperty(property: PropertyData): Promise<string> {
        this.validateProperty(property);
        const id = String(this.nextId++);
        this.properties.set(id, { ...property, id });
        return id;
    }

    async getProperty(id: string): Promise<PropertyData> {
        const property = this.properties.get(id);
        if (!property) {
            throw new StorageError(StorageErrorCode.NOT_FOUND, `Property with ID ${id} not found`);
        }
        return { ...property };
    }

    async updateProperty(id: string, property: PropertyData): Promise<void> {
        if (!this.properties.has(id)) {
            throw new StorageError(StorageErrorCode.NOT_FOUND, `Property with ID ${id} not found`);
        }
        this.validateProperty(property);
        this.properties.set(id, { ...property, id });
    }

    async deleteProperty(id: string): Promise<void> {
        if (!this.properties.delete(id)) {
            throw new StorageError(StorageErrorCode.NOT_FOUND,`Property with ID ${id} not found` );
        }
    }

    async searchByVector(vector: number[], options: SearchOptions): Promise<SearchResult[]> {
        return Array.from(this.properties.entries()).map(([id, property]) => ({
            id,
            property,
            similarity: 1.0,
            matchedFilters: []
        }));
    }

    async searchByFilters(filters: FilterGroup): Promise<SearchResult[]> {
        elizaLogger.debug('MemoryPropertyStorage: Searching by filters', {
            hasRuntime: !!this.runtime,
            filtersLength: filters?.filters?.length || 0
        });

        if (!this.runtime) {
            elizaLogger.error('MemoryPropertyStorage: Runtime not initialized for searchByFilters');
            throw new StorageError(StorageErrorCode.INTERNAL_ERROR, 'Runtime not initialized');
        }

        elizaLogger.info('Searching properties with filters:', filters);

        /* Test property creation - commented out for now
        // Test item 1 - with metadata
        const testItem1: KnowledgeItem = {
            id: stringToUuid("test-property-1-" + Date.now()),
            content: {
                text: "Property: Test Tower Location: Miami Beach Type: Mixed-Use Size: 0.5 acres",
                source: "property-data",
                metadata: {
                    name: "Test Tower",
                    location: "Miami Beach",
                    type: "Mixed-Use",
                    size: "0.5 acres"
                }
            }
        };

        // Test item 2 - without metadata
        const testItem2: KnowledgeItem = {
            id: stringToUuid("test-property-2-" + Date.now()),
            content: {
                text: "Property: Another Tower Location: Miami Beach Type: Mixed-Use Size: 0.8 acres",
                source: "property-data"
            }
        };

        elizaLogger.info('Creating test item 1:', testItem1);
        await knowledge.set(this.runtime, testItem1);
        elizaLogger.info('Test item 1 created');

        elizaLogger.info('Creating test item 2:', testItem2);
        await knowledge.set(this.runtime, testItem2);
        elizaLogger.info('Test item 2 created');
        */

        // Create a memory object for knowledge search
        const memory: Memory = {
            agentId: this.runtime.agentId,
            userId: this.runtime.agentId,
            roomId: this.runtime.agentId,
            content: {
                // Use the first filter's value as the semantic search query
                text: (filters.filters[0] as MetadataFilter).value
            }
        };

        elizaLogger.info('Memory object for knowledge search:', memory);

        // Get results from knowledge system
        const knowledgeItems = await knowledge.get(this.runtime, memory);
        elizaLogger.info('Retrieved knowledge items:', knowledgeItems);

        // Convert knowledge items to property results
        const knowledgeResults = knowledgeItems.map(item => ({
            id: item.id,
            ...(item.content.metadata ? { property: item.content.metadata as PropertyData } : {}),
            similarity: 1.0,
            matchedFilters: []
        }));

        // Apply existing filter logic to in-memory properties
        const applyFilter = (property: PropertyData, filter: MetadataFilter): boolean => {
            const value = property[filter.field as keyof PropertyData];
            const searchValue = filter.value;

            switch (filter.operator) {
                case '$eq':
                    return value === searchValue;
                case '$in':
                    if (typeof value === 'string' && typeof searchValue === 'string') {
                        return value.toLowerCase().includes(searchValue.toLowerCase());
                    }
                    return false;
                default:
                    return false;
            }
        };

        const applyFilterGroup = (property: PropertyData, group: FilterGroup): boolean => {
            const results = group.filters.map(filter => {
                if ('operator' in filter && ('filters' in filter)) {
                    // Nested filter group
                    return applyFilterGroup(property, filter as FilterGroup);
                } else {
                    // Single filter
                    return applyFilter(property, filter as MetadataFilter);
                }
            });

            return group.operator === 'AND'
                ? results.every(r => r)
                : results.some(r => r);
        };

        const directResults = Array.from(this.properties.values())
            .filter(property => applyFilterGroup(property, filters))
            .map(property => ({
                id: property.id,
                property,
                similarity: 1.0,
                matchedFilters: []
            }));

        elizaLogger.info('Direct search results:', directResults);

        // Combine and return all results
        return [...knowledgeResults, ...directResults];
    }

    async getCount(): Promise<number> {
        return this.properties.size;
    }

    async clear(): Promise<void> {
        this.properties.clear();
        this.nextId = 1;
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/storage.ts`:

```ts
import { IAgentRuntime } from '@ai16z/eliza';
import { PropertyData, SearchOptions, SearchResult, FilterGroup } from './types';
import { StorageError, StorageErrorCode } from './errors';

/**
 * Core interface for property storage operations
 */
export interface PropertyStorage {
    /**
     * Initialize the storage with runtime
     */
    initialize(runtime: IAgentRuntime): void;

    /**
     * Add a single property to storage
     * @throws {StorageError} If property is invalid or operation fails
     */
    addProperty(property: PropertyData): Promise<string>;

    /**
     * Retrieve a property by ID
     * @throws {StorageError} If property not found
     */
    getProperty(id: string): Promise<PropertyData>;

    /**
     * Update an existing property
     * @throws {StorageError} If property not found or update fails
     */
    updateProperty(id: string, property: PropertyData): Promise<void>;

    /**
     * Delete a property
     * @throws {StorageError} If property not found or delete fails
     */
    deleteProperty(id: string): Promise<void>;

    /**
     * Search properties by vector similarity
     */
    searchByVector(vector: number[], options: SearchOptions): Promise<SearchResult[]>;

    /**
     * Search properties by metadata filters
     */
    searchByFilters(filters: FilterGroup): Promise<SearchResult[]>;

    /**
     * Bulk load properties
     * @throws {StorageError} If any property is invalid or operation fails
     */
    bulkLoad(properties: PropertyData[]): Promise<void>;

    /**
     * Get total count of stored properties
     */
    getCount(): Promise<number>;

    /**
     * Clear all stored properties
     */
    clear(): Promise<void>;
}

/**
 * Abstract base class for property storage implementations
 */
export abstract class BasePropertyStorage implements PropertyStorage {
    abstract addProperty(property: PropertyData): Promise<string>;
    abstract getProperty(id: string): Promise<PropertyData>;
    abstract updateProperty(id: string, property: PropertyData): Promise<void>;
    abstract deleteProperty(id: string): Promise<void>;
    abstract searchByVector(vector: number[], options: SearchOptions): Promise<SearchResult[]>;
    abstract searchByFilters(filters: FilterGroup): Promise<SearchResult[]>;
    abstract getCount(): Promise<number>;
    abstract clear(): Promise<void>;

    /**
     * Default bulk load implementation
     * Override for more efficient implementation
     */
    async bulkLoad(properties: PropertyData[]): Promise<void> {
        try {
            await Promise.all(properties.map(p => this.addProperty(p)));
        } catch (error) {
            throw new StorageError(
                StorageErrorCode.INTERNAL_ERROR,
                `Bulk load failed: ${error}`
            );
        }
    }

    /**
     * Validate property data
     * @throws {StorageError} If property is invalid
     */
    protected validateProperty(property: PropertyData): void {
        if (!property.id || !property.name) {
            throw new StorageError(
                StorageErrorCode.INVALID_INPUT,
                'Property must have id and name'
            );
        }
    }

    /**
     * Validate vector dimensions
     * @throws {StorageError} If vector dimensions don't match
     */
    protected validateVector(vector: number[]): void {
        if (!Array.isArray(vector) || vector.length === 0) {
            throw new StorageError(
                StorageErrorCode.INVALID_INPUT,    // KAI wilder got rid of a stupid enum here
                'Invalid vector'
            );
        }
    }

    initialize(runtime: IAgentRuntime): void {
        // To be implemented by subclasses
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/errors.ts`:

```ts
export enum StorageErrorCode {
    NOT_FOUND = 'NOT_FOUND',
    ALREADY_EXISTS = 'ALREADY_EXISTS',
    INVALID_INPUT = 'INVALID_INPUT',
    INTERNAL_ERROR = 'INTERNAL_ERROR'
}

export class StorageError extends Error {
    constructor(
        public code: StorageErrorCode,
        message: string
    ) {
        super(message);
        this.name = 'StorageError';
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/plugin-spreadsheet/src/services.ts`:

```ts
import { Service, ServiceType, IAgentRuntime } from '@ai16z/eliza';
import { PropertyStorage } from './storage';
import { BasePropertyStorage } from './storage';
import { FilterGroup, SearchResult, SearchOptions } from './types';

export class PropertyStorageService extends Service implements PropertyStorage {
    private storage: BasePropertyStorage;

    constructor(storage: BasePropertyStorage) {
        super();
        this.storage = storage;
    }

    static override get serviceType(): ServiceType {
        return ServiceType.PROPERTY_STORAGE;
    }

    async initialize(runtime: IAgentRuntime): Promise<void> {
        await this.storage.initialize(runtime);
    }

    async addProperty(property: any) {
        return this.storage.addProperty(property);
    }

    async getProperty(id: string) {
        return this.storage.getProperty(id);
    }

    async updateProperty(id: string, property: any) {
        return this.storage.updateProperty(id, property);
    }

    async deleteProperty(id: string) {
        return this.storage.deleteProperty(id);
    }

    async searchByFilters(filters: FilterGroup): Promise<SearchResult[]> {
        return this.storage.searchByFilters(filters);
    }

    async searchByVector(vector: number[], options: SearchOptions): Promise<SearchResult[]> {
        return this.storage.searchByVector(vector, options);
    }

    async getCount() {
        return this.storage.getCount();
    }

    async clear() {
        return this.storage.clear();
    }

    async bulkLoad(properties: any[]) {
        return this.storage.bulkLoad(properties);
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/tsup.config.ts`:

```ts
import { defineConfig } from "tsup";

export default defineConfig({
    entry: ["src/index.ts"],
    outDir: "dist",
    sourcemap: true,
    clean: true,
    format: ["esm"], // Ensure you're targeting CommonJS
    external: [
        "dotenv", // Externalize dotenv to prevent bundling
        "fs", // Externalize fs to use Node.js built-in module
        "path", // Externalize other built-ins if necessary
        "@reflink/reflink",
        "@node-llama-cpp",
        "https",
        "http",
        "agentkeepalive",
        // Add other modules you want to externalize
    ],
});

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/index.ts`:

```ts
import { Plugin } from "@ai16z/eliza";
import { startOrder } from "./actions/startOrder.js";
import { pizzaOrderProvider } from "./providers/pizzaOrder.js";
import { endOrder } from "./actions/endOrder.js";
import { updateCustomer } from "./actions/updateCustomer.js";
import { updateOrder } from "./actions/updateOrder.js";
import { confirmOrder } from "./actions/confirmOrder.js";

export * as actions from "./actions/index.js";
export * as providers from "./providers/index.js";

export const dominosPlugin: Plugin = {
    name: "dominos",
    description: "Order a dominos pizza",
    actions: [startOrder, endOrder, updateCustomer, updateOrder, confirmOrder],
    providers: [pizzaOrderProvider],
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/PizzaOrderManager.ts`:

```ts
import { IAgentRuntime, UUID } from "@ai16z/eliza";
import { NearbyStores, Order } from "dominos";
import {
    Customer,
    ErrorType,
    OrderError,
    OrderItem,
    OrderManager,
    OrderProgress,
    OrderStatus,
    PaymentMethod,
    PaymentStatus,
    PizzaCrust,
    PizzaSize,
    PizzaTopping,
    ToppingPortion,
} from "./types";

export class PizzaOrderManager implements OrderManager {
    storeId: string;

    // System state
    availability = {
        isStoreOpen: true,
        isDeliveryAvailable: true,
        isCarryoutAvailable: true,
    };

    // Required field configuration
    requiredFields = {
        requiresCustomerName: true,
        requiresAddress: true,
        requiresPayment: true,
        requiresPhone: true,
        requiresEmail: true,
    };

    // Payment configuration
    paymentConfig = {
        acceptsCash: false,
        acceptsCredit: true,
        requiresCVV: true,
        requiresPostalCode: true,
        maxFailedAttempts: 3,
    };

    // Menu configuration
    private readonly menuConfig = {
        defaultProductCode: "PIZZA",
        basePrices: {
            [PizzaSize.SMALL]: 9.99,
            [PizzaSize.MEDIUM]: 11.99,
            [PizzaSize.LARGE]: 13.99,
            [PizzaSize.XLARGE]: 15.99,
        },
        crustPrices: {
            [PizzaCrust.HAND_TOSSED]: 0,
            [PizzaCrust.THIN]: 0,
            [PizzaCrust.PAN]: 1.0,
            [PizzaCrust.GLUTEN_FREE]: 2.5,
            [PizzaCrust.BROOKLYN]: 1.5,
        },
        toppingPrices: {
            STANDARD: 1.5,
            PREMIUM: 2.5,
            SPECIALTY: 3.5,
        },
        toppingCategories: {
            STANDARD: [
                "PEPPERONI",
                "MUSHROOMS",
                "ONIONS",
                "GREEN_PEPPERS",
                "BLACK_OLIVES",
                "TOMATOES",
            ],
            PREMIUM: [
                "ITALIAN_SAUSAGE",
                "BACON",
                "EXTRA_CHEESE",
                "GROUND_BEEF",
                "HAM",
                "PINEAPPLE",
                "JALAPENOS",
            ],
            SPECIALTY: [
                "GRILLED_CHICKEN",
                "PHILLY_STEAK",
                "FETA_CHEESE",
                "SPINACH",
                "ANCHOVIES",
                "ARTICHOKE_HEARTS",
            ],
        },
        availableToppings: {
            // Standard Toppings
            PEPPERONI: "Pepperoni",
            MUSHROOMS: "Fresh Mushrooms",
            ONIONS: "Fresh Onions",
            GREEN_PEPPERS: "Green Peppers",
            BLACK_OLIVES: "Black Olives",
            TOMATOES: "Diced Tomatoes",

            // Premium Toppings
            ITALIAN_SAUSAGE: "Italian Sausage",
            BACON: "Applewood Smoked Bacon",
            EXTRA_CHEESE: "Extra Cheese Blend",
            GROUND_BEEF: "Seasoned Ground Beef",
            HAM: "Premium Ham",
            PINEAPPLE: "Sweet Pineapple",
            JALAPENOS: "Fresh Jalapeños",

            // Specialty Toppings
            GRILLED_CHICKEN: "Grilled Chicken Breast",
            PHILLY_STEAK: "Premium Philly Steak",
            FETA_CHEESE: "Feta Cheese",
            SPINACH: "Fresh Baby Spinach",
            ANCHOVIES: "Premium Anchovies",
            ARTICHOKE_HEARTS: "Artichoke Hearts",
        },
        specialCombos: {
            MEAT_LOVERS: {
                name: "Meat Lovers",
                discount: 2.0,
                requiredToppings: [
                    "PEPPERONI",
                    "ITALIAN_SAUSAGE",
                    "BACON",
                    "HAM",
                ],
            },
            VEGGIE_SUPREME: {
                name: "Veggie Supreme",
                discount: 2.0,
                requiredToppings: [
                    "MUSHROOMS",
                    "GREEN_PEPPERS",
                    "ONIONS",
                    "BLACK_OLIVES",
                    "TOMATOES",
                ],
            },
            HAWAIIAN: {
                name: "Hawaiian",
                discount: 1.5,
                requiredToppings: ["HAM", "PINEAPPLE"],
            },
            SUPREME: {
                name: "Supreme",
                discount: 3.0,
                requiredToppings: [
                    "PEPPERONI",
                    "ITALIAN_SAUSAGE",
                    "MUSHROOMS",
                    "ONIONS",
                    "GREEN_PEPPERS",
                ],
            },
        },
        incompatibleToppings: [
            ["ANCHOVIES", "CHICKEN"], // Example of toppings that don't go well together
            ["PINEAPPLE", "ANCHOVIES"],
            ["ARTICHOKE_HEARTS", "GROUND_BEEF"],
        ],
    };

    constructor(private runtime: IAgentRuntime) {
        this.runtime = runtime;
    }

    async getNearestStoreId(address: string): Promise<string> {
        try {
            const nearbyStores = await new NearbyStores(address);

            if (nearbyStores.stores.length === 0) {
                throw new Error("No nearby stores found.");
            }

            let nearestStore: any = null;
            let minDistance = Infinity;

            for (const store of nearbyStores.stores) {
                if (
                    store.IsOnlineCapable &&
                    store.IsDeliveryStore &&
                    store.IsOpen &&
                    store.ServiceIsOpen.Delivery &&
                    store.MinDistance < minDistance
                ) {
                    minDistance = store.MinDistance;
                    nearestStore = store;
                }
            }

            if (!nearestStore) {
                throw new Error("No open stores found for delivery.");
            }

            return nearestStore.StoreID;
        } catch (error) {
            console.error("Error finding nearest store:", error);
            throw error;
        }
    }

    async getOrder(userId: UUID): Promise<Order | null> {
        const cachedOrder = await this.runtime.cacheManager.get<Order>(
            `pizza-order-${userId}`
        );
        return cachedOrder || null;
    }

    async saveOrder(userId: UUID, order: Order): Promise<void> {
        await this.runtime.cacheManager.set(`pizza-order-${userId}`, order);
    }

    async getCustomer(userId: UUID): Promise<Customer | null> {
        const customer = this.runtime.cacheManager.get<Customer>(
            `pizza-customer-${userId}`
        );
        return customer || null;
    }

    async saveCustomer(userId: UUID, customer: Customer): Promise<void> {
        await this.runtime.cacheManager.set(
            `pizza-customer-${userId}`,
            customer
        );
    }

    getNextRequiredAction(order: Order, customer: Customer): string {
        if (!order.items || order.items.length === 0) {
            return "Collect initial pizza order details";
        }

        if (!customer.name) {
            return "Request customer name";
        }

        if (!customer.phone) {
            return "Request customer phone number";
        }

        if (!customer.address) {
            return "Request delivery address";
        }

        if (!customer.email) {
            return "Request email for order confirmation";
        }

        if (!customer.paymentMethod) {
            return "Request credit card information for payment";
        }

        if (!order.progress.isConfirmed) {
            return "Review order details with customer and obtain final confirmation";
        }

        return "Provide order confirmation number and estimated delivery time";
    }

    getNextRequiredActionDialogue(order: Order, customer: Customer): string {
        if (!order.items || order.items.length === 0) {
            return "Let me help you build your perfect pizza! What size would you like?";
        }

        if (!customer.name) {
            return "Could you please tell me your name for the order?";
        }

        if (!customer.phone) {
            return "What phone number can we reach you at if needed?";
        }

        if (!customer.address) {
            return "Where would you like your pizza delivered?";
        }

        if (!customer.email) {
            return "What email address should we send your order confirmation to?";
        }

        if (!customer.paymentMethod) {
            return "To complete your order, I'll need your credit card information. Could you please provide your card number, expiration date (MM/YY), CVV, and billing zip code?";
        }

        if (!order.progress.isConfirmed) {
            return "Great! I have all your information. Would you like me to review everything before placing your order?";
        }

        return "Your order is confirmed! Let me get your confirmation number and estimated delivery time.";
    }

    // Get topping category and price
    private getToppingInfo(toppingCode: string): {
        category: string;
        price: number;
    } {
        if (this.menuConfig.toppingCategories.STANDARD.includes(toppingCode)) {
            return {
                category: "STANDARD",
                price: this.menuConfig.toppingPrices.STANDARD,
            };
        }
        if (this.menuConfig.toppingCategories.PREMIUM.includes(toppingCode)) {
            return {
                category: "PREMIUM",
                price: this.menuConfig.toppingPrices.PREMIUM,
            };
        }
        if (this.menuConfig.toppingCategories.SPECIALTY.includes(toppingCode)) {
            return {
                category: "SPECIALTY",
                price: this.menuConfig.toppingPrices.SPECIALTY,
            };
        }
        throw new Error(`Invalid topping code: ${toppingCode}`);
    }

    // Check for special combinations
    private checkSpecialCombos(toppings: PizzaTopping[]): number {
        const toppingCodes = toppings.map((t) => t.code);
        let maxDiscount = 0;

        for (const [_, combo] of Object.entries(
            this.menuConfig.specialCombos
        )) {
            if (combo.requiredToppings.every((t) => toppingCodes.includes(t))) {
                maxDiscount = Math.max(maxDiscount, combo.discount);
            }
        }

        return maxDiscount;
    }

    // Format currency
    private formatCurrency(amount: number): string {
        return `$${amount?.toFixed(2) || "?"}`;
    }

    // Format topping for display with category
    private formatTopping(topping: PizzaTopping): string {
        const toppingInfo = this.getToppingInfo(topping.code);
        const amount = topping.amount > 1 ? "Extra " : "";
        const portion =
            topping.portion === ToppingPortion.ALL
                ? "Whole Pizza"
                : `${topping.portion} Half`;
        const category =
            toppingInfo.category.charAt(0) +
            toppingInfo.category.slice(1).toLowerCase();

        return (
            `${amount}${this.menuConfig.availableToppings[topping.code]} ` +
            `(${portion}) - ${category} Topping`
        );
    }

    // Generate detailed order summary
    getOrderSummary(order: Order, customer: Customer): string {
        console.log("getOrderSummary: ", order, customer);
        let summary = "===== CURRENT ORDER =====\n\n";

        // Add items
        order.items?.forEach((item, index) => {
            summary += `PIZZA ${index + 1}\n`;
            summary += `==================\n`;
            summary += `Size: ${item.size} (${this.formatCurrency(this.menuConfig.basePrices[item.size])})\n`;
            summary += `Crust: ${item.crust.replace("_", " ")}`;

            const crustPrice = this.menuConfig.crustPrices[item.crust];
            if (crustPrice > 0) {
                summary += ` (+${this.formatCurrency(crustPrice)})\n`;
            } else {
                summary += "\n";
            }

            if (item.toppings && item.toppings.length > 0) {
                summary += "\nTOPPINGS:\n";
                item.toppings?.forEach((topping) => {
                    const toppingInfo = this.getToppingInfo(topping.code);
                    summary += `• ${this.formatTopping(topping)} `;
                    summary += `(+${this.formatCurrency(
                        toppingInfo.price *
                            topping.amount *
                            (topping.portion === ToppingPortion.ALL ? 1 : 0.5)
                    )})\n`;
                });

                const comboDiscount = this.checkSpecialCombos(item.toppings);
                if (comboDiscount > 0) {
                    summary += `\nSpecial Combination Discount: -${this.formatCurrency(comboDiscount)}\n`;
                }
            } else {
                summary += "\nClassic Cheese Pizza (No extra toppings)\n";
            }

            if (item.specialInstructions) {
                summary += `\nSpecial Instructions:\n${item.specialInstructions}\n`;
            }

            summary += `\nItem Total: ${this.formatCurrency(this.calculatePizzaPrice(item))}\n`;
            summary += "==================\n\n";
        });

        // Add customer info if available
        if (customer) {
            summary += "CUSTOMER INFORMATION\n";
            summary += "==================\n";
            if (customer.name) summary += `Name: ${customer.name}\n`;
            if (customer.phone) summary += `Phone: ${customer.phone}\n`;
            if (customer.address) {
                summary += "Delivery Address:\n";
                summary += `${(customer?.address && JSON.stringify(customer.address)) || "Not provided"}\n`;
            }
            if (customer.email) summary += `Email: ${customer.email}\n`;
            summary += "==================\n\n";
        }

        // Add payment info if available
        if (order.paymentMethod) {
            summary += "PAYMENT INFORMATION\n";
            summary += "==================\n";
            summary += `Card: ****${order.paymentMethod.cardNumber.slice(-4)}\n`;
            summary += `Status: ${order.paymentStatus}\n`;
            summary += "==================\n\n";
        }

        // Add order totals
        summary += "ORDER TOTALS\n";
        summary += "==================\n";
        summary += `Subtotal: ${this.formatCurrency(order.total)}\n`;
        const tax = order.total * 0.08; // Example tax rate
        summary += `Tax (8%): ${this.formatCurrency(tax)}\n`;
        const deliveryFee = 3.99;
        summary += `Delivery Fee: ${this.formatCurrency(deliveryFee)}\n`;
        summary += `Total: ${this.formatCurrency(order.total + tax + deliveryFee)}\n`;
        summary += "==================\n";

        return summary;
    }

    // Validate pizza toppings
    private validateToppings(toppings: PizzaTopping[]): OrderError | null {
        for (const topping of toppings) {
            // Check if topping code exists
            if (!this.menuConfig.availableToppings[topping.code]) {
                return {
                    type: ErrorType.VALIDATION_FAILED,
                    message: `Invalid topping code: ${topping.code}`,
                    code: "INVALID_TOPPING",
                };
            }

            // Check if portion is valid
            if (!Object.values(ToppingPortion).includes(topping.portion)) {
                return {
                    type: ErrorType.VALIDATION_FAILED,
                    message: `Invalid topping portion: ${topping.portion}`,
                    code: "INVALID_PORTION",
                };
            }

            // Check if amount is valid (1 for normal, 2 for extra)
            if (topping.amount !== 1 && topping.amount !== 2) {
                return {
                    type: ErrorType.VALIDATION_FAILED,
                    message: "Topping amount must be 1 (normal) or 2 (extra)",
                    code: "INVALID_AMOUNT",
                };
            }
        }

        // Check maximum number of toppings
        if (toppings.length > 10) {
            return {
                type: ErrorType.VALIDATION_FAILED,
                message: "Maximum of 10 toppings per pizza",
                code: "TOO_MANY_TOPPINGS",
            };
        }

        return null;
    }

    // Calculate pizza price including toppings and discounts
    private calculatePizzaPrice(item: OrderItem): number {
        let price =
            this.menuConfig.basePrices[item.size] ||
            this.menuConfig.basePrices[PizzaSize.MEDIUM];

        // Add crust price
        price += this.menuConfig.crustPrices[item.crust] || 0;

        // Calculate topping prices (continuing calculatePizzaPrice)
        if (item.toppings) {
            for (const topping of item.toppings) {
                const toppingInfo = this.getToppingInfo(topping.code);
                const portionMultiplier =
                    topping.portion === ToppingPortion.ALL ? 1 : 0.5;
                price += toppingInfo.price * topping.amount * portionMultiplier;
            }

            // Apply combo discounts
            const comboDiscount = this.checkSpecialCombos(item.toppings);
            price -= comboDiscount;
        }

        return price * item.quantity;
    }

    // Validate customer information
    private validateCustomerInfo(customer: Customer): OrderError | null {
        const phoneRegex = /^\d{3}[-.]?\d{3}[-.]?\d{4}$/;
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        const nameRegex = /^[a-zA-Z0-9\s'-]{2,50}$/;

        if (!customer.name || !nameRegex.test(customer.name)) {
            return {
                type: ErrorType.VALIDATION_FAILED,
                message: "Please provide a valid name (2-50 characters)",
                code: "INVALID_NAME",
            };
        }

        if (!customer.phone || !phoneRegex.test(customer.phone)) {
            return {
                type: ErrorType.VALIDATION_FAILED,
                message: "Please provide a valid 10-digit phone number",
                code: "INVALID_PHONE",
            };
        }

        if (!customer.email || !emailRegex.test(customer.email)) {
            return {
                type: ErrorType.VALIDATION_FAILED,
                message: "Please provide a valid email address",
                code: "INVALID_EMAIL",
            };
        }

        if (!customer.address || customer.address.length < 10) {
            return {
                type: ErrorType.VALIDATION_FAILED,
                message: "Please provide a complete delivery address",
                code: "INVALID_ADDRESS",
            };
        }

        return null;
    }

    // Validate payment method
    private validatePaymentMethod(payment: PaymentMethod): OrderError | null {
        const cardNumberRegex = /^\d{16}$/;
        const cvvRegex = /^\d{3,4}$/;
        const expiryRegex = /^(0[1-9]|1[0-2])\/([0-9]{2})$/;
        const postalRegex = /^\d{5}(-\d{4})?$/;

        if (!payment.cardNumber || !cardNumberRegex.test(payment.cardNumber)) {
            return {
                type: ErrorType.PAYMENT_FAILED,
                message: "Please provide a valid 16-digit credit card number",
                code: "INVALID_CARD_NUMBER",
            };
        }

        if (!payment.expiryDate || !expiryRegex.test(payment.expiryDate)) {
            return {
                type: ErrorType.PAYMENT_FAILED,
                message: "Please provide a valid expiration date (MM/YY)",
                code: "INVALID_EXPIRY",
            };
        }

        // Check if card is expired
        if (payment.expiryDate) {
            const [month, year] = payment.expiryDate.split("/");
            const expiry = new Date(2000 + parseInt(year), parseInt(month) - 1);
            if (expiry < new Date()) {
                return {
                    type: ErrorType.PAYMENT_FAILED,
                    message: "The card has expired",
                    code: "CARD_EXPIRED",
                };
            }
        }

        if (!payment.cvv || !cvvRegex.test(payment.cvv)) {
            return {
                type: ErrorType.PAYMENT_FAILED,
                message: "Please provide a valid CVV (3-4 digits)",
                code: "INVALID_CVV",
            };
        }

        if (
            this.paymentConfig.requiresPostalCode &&
            (!payment.postalCode || !postalRegex.test(payment.postalCode))
        ) {
            return {
                type: ErrorType.PAYMENT_FAILED,
                message: "Please provide a valid postal code",
                code: "INVALID_POSTAL",
            };
        }

        return null;
    }

    // Calculate order progress
    calculateOrderProgress(order: Order, customer: Customer): OrderProgress {
        return {
            hasCustomerInfo: Boolean(
                customer.name &&
                    customer.phone &&
                    customer.email &&
                    customer.address
            ),
            hasPaymentMethod: Boolean(customer.paymentMethod),
            hasValidPayment: Boolean(
                customer.paymentMethod && order.payments?.[0]?.isValid
            ),
            isConfirmed: order.status === OrderStatus.CONFIRMED,
        };
    }

    // Process the order
    async processOrder(
        order: Order,
        customer: Customer
    ): Promise<Order | OrderError> {
        // Validate pizza configuration
        if (order && order.items) {
            for (const item of order.items) {
                // Validate size
                if (!Object.values(PizzaSize).includes(item.size)) {
                    return {
                        type: ErrorType.VALIDATION_FAILED,
                        message: `Invalid pizza size: ${item.size}`,
                        code: "INVALID_SIZE",
                    };
                }

                // Validate crust
                if (!Object.values(PizzaCrust).includes(item.crust)) {
                    return {
                        type: ErrorType.VALIDATION_FAILED,
                        message: `Invalid crust type: ${item.crust}`,
                        code: "INVALID_CRUST",
                    };
                }

                // Validate toppings
                if (item.toppings) {
                    const toppingError = this.validateToppings(item.toppings);
                    if (toppingError) return toppingError;
                }

                // Validate quantity
                if (item.quantity < 1 || item.quantity > 10) {
                    return {
                        type: ErrorType.VALIDATION_FAILED,
                        message: "Quantity must be between 1 and 10",
                        code: "INVALID_QUANTITY",
                    };
                }
            }
        } else {
            console.warn("No order items found");
        }

        // Calculate total price
        if (order.items) {
            order.total = order.items?.reduce(
                (total, item) => total + this.calculatePizzaPrice(item),
                0
            );
        } else {
            console.warn("No order items found");
        }

        // Validate customer information
        const customerError = this.validateCustomerInfo(customer);
        if (customerError) return customerError;

        // Validate payment if provided
        if (order.paymentMethod) {
            const paymentError = this.validatePaymentMethod(
                order.paymentMethod
            );
            if (paymentError) {
                order.paymentStatus = PaymentStatus.INVALID;
                return paymentError;
            }
            order.paymentStatus = PaymentStatus.VALID;
        }

        // Update order progress
        order.progress = this.calculateOrderProgress(order, customer);

        // Update order status based on current state
        if (order.progress) {
            if (!order.progress.hasCustomerInfo) {
                order.status = OrderStatus.AWAITING_CUSTOMER_INFO;
            } else if (!order.progress.hasValidPayment) {
                order.status = OrderStatus.AWAITING_PAYMENT;
            } else if (!order.progress.isConfirmed) {
                order.status = OrderStatus.PROCESSING;
            } else {
                order.status = OrderStatus.CONFIRMED;
            }
        }

        return order;
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/actions/updateOrder.ts`:

```ts
import {
    Action,
    ActionExample,
    composeContext,
    generateObjectV2,
    Handler,
    IAgentRuntime,
    Memory,
    ModelClass,
    State,
} from "@ai16z/eliza";
import { Item } from "dominos";
import { PizzaCrust, PizzaSize, ToppingPortion } from "../types";

import { z } from "zod";
import { PizzaOrderManager } from "../PizzaOrderManager";

const ModificationSchema = z.object({
    type: z.enum([
        "UPDATE_SIZE",
        "UPDATE_CRUST",
        "ADD_TOPPING",
        "REMOVE_TOPPING",
        "ADD_PIZZA",
        "UPDATE_QUANTITY",
        "UPDATE_INSTRUCTIONS",
    ]),
    itemIndex: z.number().int().min(0),
    data: z.object({
        size: z.enum(["SMALL", "MEDIUM", "LARGE", "XLARGE"]).optional(),
        crust: z
            .enum(["HAND_TOSSED", "THIN", "PAN", "GLUTEN_FREE", "BROOKLYN"])
            .optional(),
        topping: z
            .object({
                code: z.string(),
                portion: z.enum(["LEFT", "RIGHT", "ALL"]),
                amount: z.union([z.literal(1), z.literal(2)]),
            })
            .optional(),
        quantity: z.number().int().positive().optional(),
        specialInstructions: z.string().optional(),
        newPizza: z
            .object({
                size: z.enum(["SMALL", "MEDIUM", "LARGE", "XLARGE"]),
                crust: z.enum([
                    "HAND_TOSSED",
                    "THIN",
                    "PAN",
                    "GLUTEN_FREE",
                    "BROOKLYN",
                ]),
                toppings: z
                    .array(
                        z.object({
                            code: z.string(),
                            portion: z.enum(["LEFT", "RIGHT", "ALL"]),
                            amount: z.union([z.literal(1), z.literal(2)]),
                        })
                    )
                    .optional(),
                quantity: z.number().int().positive(),
                specialInstructions: z.string().optional(),
            })
            .optional(),
    }),
});

type OrderModifications = {
    modifications: z.infer<typeof ModificationSchema>[];
};

export const handler: Handler = async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State
) => {
    const orderManager = new PizzaOrderManager(runtime);
    const userId = message.userId;

    // Get active order and customer
    const order = await orderManager.getOrder(userId);
    if (!order) {
        return "There is no active order to update. Please start a new order first.";
    }

    const customer = await orderManager.getCustomer(userId);
    if (!customer) {
        return "Customer details not found. Please provide customer information first.";
    }

    // Extract order modifications using LLM and schema
    const extractionTemplate = `
    Extract pizza order modifications from the conversation. Consider all types of changes:
    - Size changes
    - Crust changes
    - Adding/removing toppings
    - Quantity changes
    - Special instructions
    - Adding new pizzas

    Current order:
    ${orderManager.getOrderSummary(order, customer)}

    {{recentConversation}}

    Provide the modifications as an array of change operations:
    {
        "modifications": [{
            "type": "UPDATE_SIZE" | "UPDATE_CRUST" | "ADD_TOPPING" | "REMOVE_TOPPING" | "ADD_PIZZA" | "UPDATE_QUANTITY" | "UPDATE_INSTRUCTIONS",
            "itemIndex": number,
            "data": {
                // For size updates
                "size": string,
                // For crust updates
                "crust": string,
                // For topping changes
                "topping": {
                    "code": string,
                    "portion": "LEFT" | "RIGHT" | "ALL",
                    "amount": 1 | 2
                },
                // For quantity updates
                "quantity": number,
                // For special instructions
                "specialInstructions": string,
                // For new pizzas
                "newPizza": {
                    "size": string,
                    "crust": string,
                    "toppings": array,
                    "quantity": number,
                    "specialInstructions": string
                }
            }
        }]
    }
    `;

    const context = composeContext({
        state,
        template: extractionTemplate,
    });

    try {
        const orderUpdates = (await generateObjectV2({
            runtime,
            context,
            modelClass: ModelClass.LARGE,
            schema: z.object({
                modifications: z.array(ModificationSchema),
            }),
        })) as unknown as OrderModifications;

        // Apply modifications
        for (const mod of orderUpdates.modifications) {
            const item = order.items && order.items[mod.itemIndex];
            if (!item) continue;

            switch (mod.type) {
                case "UPDATE_SIZE":
                    if (mod.data.size) item.size = mod.data.size as PizzaSize;
                    break;

                case "UPDATE_CRUST":
                    if (mod.data.crust)
                        item.crust = mod.data.crust as PizzaCrust;
                    break;

                case "ADD_TOPPING":
                    if (mod.data.topping) {
                        if (!item.toppings) item.toppings = [];
                        item.toppings.push({
                            code: mod.data.topping.code,
                            portion: mod.data.topping.portion as ToppingPortion,
                            amount: mod.data.topping.amount,
                        });
                    }
                    break;

                case "REMOVE_TOPPING":
                    if (mod.data.topping && item.toppings) {
                        item.toppings = item.toppings.filter(
                            (t) =>
                                t.code !== mod.data.topping.code ||
                                t.portion !== mod.data.topping.portion
                        );
                    }
                    break;

                case "ADD_PIZZA":
                    if (mod.data.newPizza) {
                        const newItem = new Item({
                            code: "PIZZA",
                            size: mod.data.newPizza.size as PizzaSize,
                            crust: mod.data.newPizza.crust as PizzaCrust,
                            toppings:
                                mod.data.newPizza.toppings?.map((t) => ({
                                    ...t,
                                    portion: t.portion as ToppingPortion,
                                })) || [],
                            quantity: mod.data.newPizza.quantity,
                            specialInstructions:
                                mod.data.newPizza.specialInstructions,
                        });
                        order.addItem(newItem);
                    }
                    break;

                case "UPDATE_QUANTITY":
                    if (mod.data.quantity) item.quantity = mod.data.quantity;
                    break;

                case "UPDATE_INSTRUCTIONS":
                    if (mod.data.specialInstructions) {
                        item.specialInstructions = mod.data.specialInstructions;
                    }
                    break;
            }
        }

        // Process updated order
        const processedOrder = await orderManager.processOrder(order, customer);
        if (!("type" in processedOrder)) {
            await orderManager.saveOrder(userId, processedOrder);
        }

        let response = "I've updated your order.\n\n";
        response += orderManager.getOrderSummary(order, customer);
        response +=
            "\n" + orderManager.getNextRequiredActionDialogue(order, customer);

        return response;
    } catch (error) {
        return "I couldn't understand the requested changes. Please try again with clearer modifications.";
    }
};

export const updateOrder: Action = {
    name: "UPDATE_ORDER",
    description: "Updates an existing pizza order with new order details.",
    similes: ["MODIFY_ORDER", "CHANGE_ORDER", "SET_ORDER"],
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Can you make that a large pizza instead of medium?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've updated your pizza size to Large. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Add extra cheese to my pizza",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've added extra cheese to your pizza. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Change the crust to thin crust please",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've changed your crust to Thin Crust. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Add pepperoni to the whole pizza",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've added pepperoni to your pizza. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Can I get mushrooms on half of it?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've added mushrooms to half of your pizza. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Make it a gluten free crust",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've updated your crust to Gluten Free. Note that there's a $2.50 upcharge for gluten-free crust. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Add another pizza to my order - medium with pepperoni",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've added a Medium Pepperoni Pizza to your order. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Can you make it well done?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've added a special instruction for well-done cooking. Here's your updated order summary...",
                    action: "UPDATE_ORDER",
                },
            },
        ],
    ] as ActionExample[][],
    handler: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;

        // Get the active order
        const order = await orderManager.getOrder(userId);
        if (!order) {
            return "There is no active order to update. Please start a new order first.";
        }

        // Get the customer details
        const customer = await orderManager.getCustomer(userId);
        if (!customer) {
            return "Customer details not found. Please provide customer information.";
        }

        // TODO: Update order details based on user input
        // This could include adding/removing items, updating customer info, etc.

        // Validate and process the updated order
        const processedOrder = await orderManager.processOrder(order, customer);
        if (!("type" in processedOrder)) {
            await orderManager.saveOrder(userId, processedOrder);
            await orderManager.saveCustomer(userId, customer);
        }

        // Provide updated order summary and prompt for next action
        let response = "Your order has been updated.\n\n";
        response += orderManager.getOrderSummary(order, customer);

        response += orderManager.getNextRequiredActionDialogue(order, customer);

        return response;
    },
    validate: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;

        // Check if there is an active order
        const existingOrder = await orderManager.getOrder(userId);

        // Only validate if there is an active order
        return !!existingOrder;
    },
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/actions/index.ts`:

```ts
export * from "./startOrder.js";

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/actions/updateCustomer.ts`:

```ts
import {
    Action,
    ActionExample,
    composeContext,
    generateObjectV2,
    Handler,
    IAgentRuntime,
    Memory,
    ModelClass,
    State,
} from "@ai16z/eliza";
import { Customer, Payment } from "dominos";
import { z } from "zod";
import { PizzaOrderManager } from "../PizzaOrderManager";

// Shared schemas
const CustomerSchema = z.object({
    name: z.string().min(2).optional(),
    phone: z
        .string()
        .regex(/^\d{3}[-.]?\d{3}[-.]?\d{4}$/)
        .optional(),
    email: z.string().email().optional(),
    address: z.string().min(10).optional(),
    paymentMethod: z
        .object({
            cardNumber: z.string().regex(/^\d{16}$/),
            expiryDate: z.string().regex(/^(0[1-9]|1[0-2])\/([0-9]{2})$/),
            cvv: z.string().regex(/^\d{3,4}$/),
            postalCode: z.string().regex(/^\d{5}$/),
        })
        .optional(),
});

export const handler: Handler = async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State
) => {
    const orderManager = new PizzaOrderManager(runtime);
    const userId = message.userId;

    // Get active order and customer
    const order = await orderManager.getOrder(userId);
    if (!order) {
        return "There is no active order to update customer details for. Please start a new order first.";
    }

    let customer = await orderManager.getCustomer(userId);
    if (!customer) {
        customer = new Customer({});
    }

    // Extract customer details using LLM and schema
    const extractionTemplate = `
Extract customer information from the following conversation. Keep existing information if not mentioned in the update.

Current customer information:
Name: ${customer.name || "Not provided"}
Phone: ${customer.phone || "Not provided"}
Email: ${customer.email || "Not provided"}
Address: ${customer.address || "Not provided"}
Payment: ${customer.paymentMethod ? "Provided" : "Not provided"}

{{recentConversation}}

Provide updated customer information as a JSON object, including only fields that should be changed:
{
    "name": string (optional),
    "phone": string (optional, format: XXX-XXX-XXXX),
    "email": string (optional, valid email),
    "address": string (optional, full delivery address),
    "paymentMethod": {
        "cardNumber": string (16 digits),
        "expiryDate": string (MM/YY),
        "cvv": string (3-4 digits),
        "postalCode": string (5 digits)
    }
}
`;

    const context = composeContext({
        state,
        template: extractionTemplate,
    });

    try {
        const customerUpdates = (await generateObjectV2({
            runtime,
            context,
            modelClass: ModelClass.LARGE,
            schema: CustomerSchema,
        })) as z.infer<typeof CustomerSchema>;

        // Update only provided fields
        if (customerUpdates.name) customer.name = customerUpdates.name;
        if (customerUpdates.phone) customer.phone = customerUpdates.phone;
        if (customerUpdates.email) customer.email = customerUpdates.email;
        if (customerUpdates.address) customer.address = customerUpdates.address;

        // Update the handler logic
        if (customerUpdates.paymentMethod) {
            // Create Dominos Payment object
            const payment = new Payment({
                number: customerUpdates.paymentMethod.cardNumber,
                expiration: customerUpdates.paymentMethod.expiryDate,
                securityCode: customerUpdates.paymentMethod.cvv,
                postalCode: customerUpdates.paymentMethod.postalCode,
                amount: order.amountsBreakdown.customer,
            });

            // Clear existing payments and add new one
            order.payments = [payment];

            // Update customer payment method
            customer.paymentMethod = customerUpdates.paymentMethod;
        }

        await orderManager.saveCustomer(userId, customer);

        // Process updated order
        const processedOrder = await orderManager.processOrder(order, customer);
        if (!("type" in processedOrder)) {
            await orderManager.saveOrder(userId, processedOrder);
        }

        let response = "I've updated your customer information.\n\n";
        response += orderManager.getOrderSummary(order, customer);
        response +=
            "\n" + orderManager.getNextRequiredActionDialogue(order, customer);

        return response;
    } catch (error) {
        return "I couldn't understand the customer information provided. Please try again with clearer details.";
    }
};

export const updateCustomer: Action = {
    name: "UPDATE_CUSTOMER",
    description: "Updates customer information based on the message text.",
    similes: [
        "UPDATE_CUSTOMER_DETAILS",
        "UPDATE_CUSTOMER_INFO",
        "SET_CUSTOMER",
        "CHANGE_CUSTOMER_INFO",
        "MODIFY_CUSTOMER",
    ],
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "My name is John Smith, phone number is 555-123-4567",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Thanks John, I've updated your contact information. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Deliver to 123 Main Street, Apt 4B, New York, NY 10001",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've updated your delivery address. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "My email is john.smith@email.com",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've added your email address. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Change my phone number to 555-987-6543",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've updated your phone number. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Update my info - Sarah Johnson, sarah.j@email.com, 555-555-5555, 456 Oak Ave, Chicago IL 60601",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Thanks Sarah, I've updated all your customer information. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Need to change my address to 789 Pine Street, Suite 301, Boston MA 02108",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've updated your delivery address. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Can you update my contact details? Name: Mike Wilson, Phone: 555-111-2222",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've updated your name and phone number, Mike. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Change everything to: Alex Lee, alex@email.com, 555-333-4444, 321 Maple Drive, Austin TX 78701",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Thanks Alex, I've updated all your customer information. Here's your updated order summary...",
                    action: "UPDATE_CUSTOMER",
                },
            },
        ],
    ] as ActionExample[][],
    handler,
    validate: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;

        // Check if there is an active order
        const existingOrder = await orderManager.getOrder(userId);

        // Only validate if there is an active order
        return !!existingOrder;
    },
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/actions/endOrder.ts`:

```ts
import { Action, ActionExample, IAgentRuntime, Memory } from "@ai16z/eliza";
import { PizzaOrderManager } from "../PizzaOrderManager";

export const endOrder: Action = {
    name: "CANCEL_ORDER",
    description: "Ends the current pizza order and clears the order data.",
    similes: ["END_ORDER", "FINISH_ORDER", "COMPLETE_ORDER", "STOP_ORDER"],
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Actually, I need to cancel my order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "nevermind, cancel the pizza order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "stop the order please",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "can you cancel my pizza order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "I changed my mind, don't want pizza anymore",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "end order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "sorry but I need to cancel this order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "stop my dominos order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "finish order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "cancel everything",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "hey can you clear my current order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "scratch that order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Your order has been canceled.",
                    action: "CANCEL_ORDER",
                },
            },
        ],
    ] as ActionExample[][],
    handler: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;

        // Get the active order
        const order = await orderManager.getOrder(userId);
        if (!order) {
            return "There is no active order to end.";
        }

        // Clear the order data
        await runtime.cacheManager.delete(`pizza-order-${userId}`);
        await runtime.cacheManager.delete(`pizza-customer-${userId}`);

        return "Your order has been canceled.";
    },
    validate: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;

        // Check if there is an active order
        const existingOrder = await orderManager.getOrder(userId);

        // Only validate if there is an active order
        return !!existingOrder;
    },
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/actions/confirmOrder.ts`:

```ts
import { Action, IAgentRuntime, Memory } from "@ai16z/eliza";
import { PizzaOrderManager } from "../PizzaOrderManager";
import { OrderStatus } from "../types";

export const confirmOrder: Action = {
    name: "CONFIRM_ORDER",
    similes: ["FINALIZE_ORDER", "FINISH_ORDER", "PLACE_ORDER"],
    examples: [
        // TODO
    ],
    description: "Confirms and places the final order with Dominos",
    validate: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;
        const order = await orderManager.getOrder(userId);
        const customer = await orderManager.getCustomer(userId);

        if (!order || !customer) return false;

        // Only valid if we have complete customer info and valid payment
        return (
            order.progress &&
            order.progress.hasCustomerInfo &&
            order.progress.hasValidPayment &&
            !order.progress.isConfirmed
        );
    },
    handler: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;
        const order = await orderManager.getOrder(userId);
        const customer = await orderManager.getCustomer(userId);

        try {
            // Final validation with Dominos
            await order.validate();

            // Get final pricing
            await order.price();

            // Place the order
            await order.place();

            // Update order status
            order.status = OrderStatus.CONFIRMED;
            await orderManager.saveOrder(userId, order);

            return (
                `Great news! Your order has been confirmed and is being prepared.\n\n` +
                `Order Number: ${order.orderID}\n` +
                `Estimated Delivery Time: ${order.estimatedWaitMinutes} minutes\n\n` +
                orderManager.getOrderSummary(order, customer)
            );
        } catch (error) {
            return "There was an issue placing your order: " + error.message;
        }
    },
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/actions/startOrder.ts`:

```ts
import {
    Action,
    ActionExample,
    composeContext,
    generateObjectV2,
    Handler,
    IAgentRuntime,
    Memory,
    ModelClass,
    State,
} from "@ai16z/eliza";
import { Customer, Item, Order } from "dominos";
import { PizzaCrust, PizzaSize } from "../types";

import { z } from "zod";
import { PizzaOrderManager } from "../PizzaOrderManager";

const handler: Handler = async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State
) => {
    const orderManager = new PizzaOrderManager(runtime);
    const userId = message.userId;

    // Check for existing order
    const existingOrder = await orderManager.getOrder(userId);
    if (existingOrder) {
        return "There is already an active order. Please complete or cancel the existing order before starting a new one.";
    }

    console.log("Existing order: ", existingOrder);

    // Extract order details from message using LLM
    const extractionTemplate = `
      Extract pizza order details from the following text. Include size, crust type, toppings, quantity, and any special instructions.
      If information is missing, use default values: medium size, hand tossed crust, no toppings, quantity 1.

      {{recentConversation}}

      Format the response as a JSON object with these fields:
      {
        "size": "SMALL"|"MEDIUM"|"LARGE"|"XLARGE",
        "crust": "HAND_TOSSED"|"THIN"|"PAN"|"GLUTEN_FREE"|"BROOKLYN",
        "toppings": [{"code": string, "portion": "LEFT"|"RIGHT"|"ALL", "amount": 1|2}],
        "quantity": number,
        "specialInstructions": string
      }
    `;

    const context = composeContext({
        state,
        template: extractionTemplate,
    });

    const PizzaOrderSchema = z.object({
        size: z.enum(["SMALL", "MEDIUM", "LARGE", "XLARGE"]),
        crust: z.enum([
            "HAND_TOSSED",
            "THIN",
            "PAN",
            "GLUTEN_FREE",
            "BROOKLYN",
        ]),
        toppings: z
            .array(
                z.object({
                    code: z.string(),
                    portion: z.enum(["LEFT", "RIGHT", "ALL"]),
                    amount: z.union([z.literal(1), z.literal(2)]),
                })
            )
            .optional(),
        quantity: z.number().int().positive(),
        specialInstructions: z.string().optional(),
    });

    try {
        const orderDetails = (await generateObjectV2({
            runtime,
            context,
            modelClass: ModelClass.LARGE,
            schema: PizzaOrderSchema,
        })) as z.infer<typeof PizzaOrderSchema>;

        // Create new order
        const customer = new Customer({});
        await orderManager.saveCustomer(userId, customer);

        const order = new Order(customer);

        // Add extracted item
        const item = new Item({
            code: "PIZZA",
            size: orderDetails.size,
            crust: orderDetails.crust,
            toppings: orderDetails.toppings || [],
            quantity: orderDetails.quantity,
            specialInstructions: orderDetails.specialInstructions,
        });

        order.addItem(item);
        await orderManager.saveOrder(userId, order);

        // Generate response
        let response = "Great! I've started a new pizza order for you.\n\n";
        response += orderManager.getOrderSummary(order, customer);
        response +=
            "\n" + orderManager.getNextRequiredActionDialogue(order, customer);

        return response;
    } catch (error) {
        // Fallback to basic order if extraction fails
        const customer = new Customer({});
        await orderManager.saveCustomer(userId, customer);

        const order = new Order(customer);
        const defaultItem = new Item({
            code: "PIZZA",
            size: PizzaSize.MEDIUM,
            crust: PizzaCrust.HAND_TOSSED,
            quantity: 1,
        });

        order.addItem(defaultItem);
        await orderManager.saveOrder(userId, order);

        let response =
            "I've started a new pizza order with default options.\n\n";
        response += orderManager.getOrderSummary(order, customer);
        response +=
            "\n" + orderManager.getNextRequiredActionDialogue(order, customer);

        return response;
    }
};

export const startOrder: Action = {
    name: "START_ORDER",
    description: "Starts a new pizza order.",
    similes: ["BEGIN_ORDER", "CREATE_ORDER", "NEW_ORDER"],
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "I'd like to order a pizza please",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll help you build your perfect pizza! What size would you like? We have Small, Medium, Large and Extra Large.",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Can you help me order some Dominos?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Of course! I'll help you place your Dominos order. Let's start with the size - would you like a Small, Medium, Large, or Extra Large pizza?",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "start pizza order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Let's get your pizza order started! What size pizza would you like? We offer Small, Medium, Large and Extra Large options.",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "im hungry for some dominos",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I can help you order Dominos! First, what size pizza would you like - Small, Medium, Large, or Extra Large?",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "new pizza order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll help you place your order! To get started, what size pizza would you prefer? We have Small, Medium, Large and Extra Large available.",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "hey can you order me a large pepperoni pizza",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll help you order a Large pizza! Before we add the pepperoni, would you like our Hand Tossed, Thin, Pan, Brooklyn, or Gluten Free crust?",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "begin dominos order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll help you order from Dominos! Let's start by choosing your pizza size - would you like Small, Medium, Large, or Extra Large?",
                    action: "START_ORDER",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "place pizza order",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Happy to help you order a pizza! First things first - what size would you like? You can choose from Small, Medium, Large, or Extra Large.",
                    action: "START_ORDER",
                },
            },
        ],
    ] as ActionExample[][],
    handler,
    validate: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);
        const userId = message.userId;

        // Check if there is an active order
        const existingOrder = await orderManager.getOrder(userId);

        // Only validate if there is no active order
        return !existingOrder;
    },
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/types.ts`:

```ts
// Order status enums
enum OrderStatus {
    NEW = "NEW",
    AWAITING_CUSTOMER_INFO = "AWAITING_CUSTOMER_INFO",
    AWAITING_PAYMENT = "AWAITING_PAYMENT",
    AWAITING_CONFIRMATION = "AWAITING_CONFIRMATION",
    PROCESSING = "PROCESSING",
    CONFIRMED = "CONFIRMED",
    FAILED = "FAILED",
}

interface Order {
    status: OrderStatus;
    paymentStatus: PaymentStatus;
    paymentMethod?: PaymentMethod;
    customer?: Customer;
    items?: OrderItem[];
}

// Order progress tracking
interface OrderProgress {
    hasCustomerInfo: boolean;
    hasPaymentMethod: boolean;
    hasValidPayment: boolean;
    isConfirmed: boolean;
}

// Payment status types
enum PaymentStatus {
    NOT_PROVIDED = "NOT_PROVIDED",
    INVALID = "INVALID",
    VALID = "VALID",
    ON_FILE = "ON_FILE",
    PROCESSED = "PROCESSED",
}

// Payment method interface
interface PaymentMethod {
    type: string;
    cardNumber?: string;
    expiryDate?: string;
    cvv?: string;
    postalCode?: string;
    isValid: boolean;
}

// Customer interface
interface Customer {
    id?: string;
    name: string;
    phone: string;
    email: string;
    address: string;
    paymentMethod?: {
        cardNumber?: string;
        expiryDate?: string;
        cvv?: string;
        postalCode?: string;
    };
    isReturning: boolean;
}

// Pizza size enum
enum PizzaSize {
    SMALL = "SMALL",
    MEDIUM = "MEDIUM",
    LARGE = "LARGE",
    XLARGE = "XLARGE",
}

// Pizza crust enum
enum PizzaCrust {
    HAND_TOSSED = "HAND_TOSSED",
    THIN = "THIN",
    PAN = "PAN",
    GLUTEN_FREE = "GLUTEN_FREE",
    BROOKLYN = "BROOKLYN",
}

// Topping portion enum
enum ToppingPortion {
    LEFT = "LEFT",
    RIGHT = "RIGHT",
    ALL = "ALL",
}

// Pizza topping interface
interface PizzaTopping {
    code: string;
    portion: ToppingPortion;
    amount: number; // 1 for normal, 2 for extra
}

// Order item interface
interface OrderItem {
    productCode: string;
    size: PizzaSize;
    crust: PizzaCrust;
    quantity: number;
    toppings: PizzaTopping[];
    specialInstructions?: string;
}

// Error types
enum ErrorType {
    PAYMENT_FAILED = "PAYMENT_FAILED",
    VALIDATION_FAILED = "VALIDATION_FAILED",
    CUSTOMER_NOT_FOUND = "CUSTOMER_NOT_FOUND",
    SYSTEM_ERROR = "SYSTEM_ERROR",
    NETWORK_ERROR = "NETWORK_ERROR",
}

// Custom error interface
interface OrderError {
    type: ErrorType;
    message: string;
    code: string;
    details?: any;
}

// Order provider interface
export interface OrderManager {
    storeId: string;
    availability: {
        isStoreOpen: boolean;
        isDeliveryAvailable: boolean;
        isCarryoutAvailable: boolean;
    };
    requiredFields: {
        requiresCustomerName: boolean;
        requiresAddress: boolean;
        requiresPayment: boolean;
        requiresPhone: boolean;
        requiresEmail: boolean;
    };
    paymentConfig: {
        acceptsCash: boolean;
        acceptsCredit: boolean;
        requiresCVV: boolean;
        requiresPostalCode: boolean;
        maxFailedAttempts: number;
    };
}

// Event types for state management
type OrderEvent =
    | { type: "UPDATE_CUSTOMER_INFO"; payload: Partial<Customer> }
    | { type: "ADD_ITEM"; payload: OrderItem }
    | { type: "REMOVE_ITEM"; payload: string }
    | { type: "UPDATE_PAYMENT"; payload: PaymentMethod }
    | { type: "PROCESS_ORDER"; payload: Order }
    | { type: "HANDLE_ERROR"; payload: OrderError };

// Export all types
export {
    OrderStatus,
    PaymentStatus,
    PizzaSize,
    PizzaCrust,
    ToppingPortion,
    ErrorType,
    type OrderProgress,
    type PaymentMethod,
    type Customer,
    type PizzaTopping,
    type OrderItem,
    type Order,
    type OrderError,
    type OrderEvent,
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/providers/index.ts`:

```ts
export * from "./pizzaOrder.js";

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/plugin-dominos/src/providers/pizzaOrder.ts`:

```ts
import { IAgentRuntime, Memory, Provider } from "@ai16z/eliza";
import { PizzaOrderManager } from "../PizzaOrderManager";
import { OrderStatus, PaymentStatus } from "../types";

export const pizzaOrderProvider: Provider = {
    get: async (runtime: IAgentRuntime, message: Memory) => {
        const orderManager = new PizzaOrderManager(runtime);

        const userId = message.userId;
        const order = await orderManager.getOrder(userId);
        const customer = await orderManager.getCustomer(userId);
        if (!order) {
            return "No active pizza order. The customer needs to start a new order.";
        }

        // Add payment-specific status to context
        let context = "\nPAYMENT STATUS:\n";
        context += `Current Status: ${order.paymentStatus}\n`;
        if (order.paymentStatus === PaymentStatus.NOT_PROVIDED) {
            context += "Payment information needed to complete order.\n";
        } else if (order.paymentStatus === PaymentStatus.INVALID) {
            context +=
                "Previous payment method was invalid. Please provide new payment information.\n";
        }

        // Add clearer next action guidance
        if (order.status === OrderStatus.AWAITING_PAYMENT) {
            context +=
                "\nREQUIRED: Please provide credit card information to complete your order.\n";
        } else if (order.status === OrderStatus.PROCESSING) {
            context +=
                "\nREQUIRED: Please review your order and confirm to place it.\n";
        }

        context += "=== PIZZA ORDER STATUS ===\n\n";

        // Add order summary
        context += orderManager.getOrderSummary(order, customer);

        // Add next required action
        context += "\nNEXT REQUIRED ACTION:\n";
        context += orderManager.getNextRequiredAction(order, customer);

        // Add store status
        context += "\n\nSTORE STATUS:\n";
        context += `Store Open: ${orderManager.availability.isStoreOpen ? "Yes" : "No"}\n`;
        context += `Delivery Available: ${orderManager.availability.isDeliveryAvailable ? "Yes" : "No"}\n`;
        context += `Carryout Available: ${orderManager.availability.isCarryoutAvailable ? "Yes" : "No"}\n`;

        // Add order status
        context += "\nORDER STATUS:\n";
        context += `Current Status: ${order.status}\n`;
        if (order.status === OrderStatus.CONFIRMED) {
            context += "Order is confirmed and being prepared.\n";
        } else if (order.status === OrderStatus.PROCESSING) {
            context += "Order is being processed but needs confirmation.\n";
        }

        console.log("Order context:\n", context);

        return context;
    },
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/archive/adapters/PostgresLandDataProvider.ts`:

```ts
import { LandDatabaseAdapter } from '../../src/database/land_database_adapter';
import { ILandDataProvider } from '../../property-search-design/interfaces/ILandDataProvider';
import { LandPlotMemory, LandSearchParams } from '../../src/types';
import { UUID } from '@ai16z/eliza';

export class PostgresLandDataProvider implements ILandDataProvider {
    constructor(private readonly dbAdapter: LandDatabaseAdapter) {}

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        await this.dbAdapter.createLandMemory(memory);
    }

    async getLandMemoryById(id: string): Promise<LandPlotMemory> {
        return await this.dbAdapter.getLandMemoryById(id);
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
        return await this.dbAdapter.getLandMemories(roomId);
    }

    async removeLandMemory(id: string): Promise<void> {
        await this.dbAdapter.removeLandMemory(id);
    }

    async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.dbAdapter.removeAllLandMemories(roomId);
    }

    async searchLandMemories(roomId: UUID, query: string, params?: Partial<LandSearchParams>): Promise<LandPlotMemory[]> {
        return await this.dbAdapter.searchLandMemories(roomId, query, params);
    }

    async updateLandMemory(memory: LandPlotMemory): Promise<void> {
        await this.dbAdapter.updateLandMemory(memory);
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/index.ts`:

```ts
import { unrealAgentAction } from "./actions";
import { startPropertySearch } from "./initialSearchAction";
import { processPropertySearch } from "./searchProcessingAction";
import { endPropertySearch } from "./endSearchAction";
import { factEvaluator } from "./evaluators";
import { propertySearchProvider } from "./searchContextProvider";
import { Plugin } from "@ai16z/eliza";
import { PropertySearchManager } from "./searchManager";
import { PostgresLandDataProvider } from "./adapters/PostgresLandDataProvider";
import { DistanceCategory, SearchMetadata } from "./types";
import { LandDatabaseAdapter } from "./database/land_database_adapter";

export { PostgresDatabaseAdapter } from '@ai16z/adapter-postgres'
export *  from "./types";
export * as actions from "./actions";
export * as providers from "./providers";
export { PropertySearchManager } from "./searchManager";
export { PostgresLandDataProvider } from "./adapters/PostgresLandDataProvider";
export { SearchMetadata } from "./types";
export { LandDatabaseAdapter} from "./database/land_database_adapter"
//export { Post}
export const unrealPlugin: Plugin = {
    name: "unreal",
    description: "Unreal Agent with basic actions and evaluators",
    actions: [startPropertySearch, processPropertySearch, endPropertySearch],
    evaluators: [],
    providers: [propertySearchProvider],
};

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/searchContextProvider.ts`:

```ts
import { Provider } from "@ai16z/eliza";
import { PropertySearchManager, SearchSession } from "./searchManager";
import { LandPlotMemory, LandSearchParams } from "./types";


export const propertySearchProvider: Provider = {
    get: async (runtime, message) => {
        const searchManager = new PropertySearchManager(runtime);

        const session = await searchManager.getSearchSession(message.userId);

        if (!session || session.status === "INACTIVE") {
            return "\nThe user has not started a Wilder World property search session.\n";
        }

        let context = `\n# Wilder World propery search session:\n
The user is currently searching for Wilder World properties. Current property search session:\n`;

        if (session.lastQuery) {
            context += `Last search: "${session.lastQuery}"\n`;
        }

        if (session.results.length > 0) {
            context += `Found ${session.results.length} properties in last search.\n`;
            const neighborhoods = [...new Set(session.results.map(r => r.content.metadata.neighborhood))];
            context += `Properties found in: ${neighborhoods.join(", ")}\n`;

            const zoningTypes = [...new Set(session.results.map(r => r.content.metadata.zoning))];
            context += `Zoning types: ${zoningTypes.join(", ")}\n`;
        }

        if (Object.keys(session.filters).length > 0) {
            context += `\nActive filters:\n`;
            const filters = session.filters;

            if (filters.neighborhoods?.length) {
                context += `- Neighborhoods: ${filters.neighborhoods.join(", ")}\n`;
            }
            if (filters.zoningTypes?.length) {
                context += `- Zoning types: ${filters.zoningTypes.join(", ")}\n`;
            }
            if (filters.plotSizes?.length) {
                context += `- Plot sizes: ${filters.plotSizes.join(", ")}\n`;
            }
            if (filters.buildingTypes?.length) {
                context += `- Building types: ${filters.buildingTypes.join(", ")}\n`;
            }
            if (filters.distances?.ocean) {
                context += `- Max ocean distance: ${filters.distances.ocean.maxMeters}m\n`;
            }
            if (filters.distances?.bay) {
                context += `- Max bay distance: ${filters.distances.bay.maxMeters}m\n`;
            }
            if (filters.building?.floors) {
                const { min, max } = filters.building.floors;
                context += `- Floors: ${min || '0'}-${max || 'unlimited'}\n`;
            }
            if (filters.rarity?.rankRange) {
                const { min, max } = filters.rarity.rankRange;
                context += `- Rank range: ${min || '0'}-${max || 'unlimited'}\n`;
            }
        }

        return context;
    }
};
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/types.ts`:

```ts
import { Memory, UUID } from "@ai16z/eliza";
import { z } from "zod";

export enum PlotSize {
    Nano = 'Nano',
    Micro = 'Micro',
    Mini = 'Mini',
    Mid = 'Mid',
    Macro = 'Macro',
    Mega = 'Mega',
    Mammoth = 'Mammoth',
    Giga = 'Giga'
}

export enum ZoningType {
    Residential = 'Residential',
    Commercial = 'Commercial',
    Industrial = 'Industrial',
    Mixed = 'Mixed Use',  // Note: Changed to "Mixed Use"
    Legendary = 'Legendary'
}

export enum BuildingType {
    Lowrise = 'Lowrise',    // 2-20 floors
    Midrise = 'Midrise',    // 21-35 floors
    Highrise = 'Highrise',  // 36-65 floors
    Tall = 'Tall',          // 66-80 floors
    Supertall = 'Supertall',// 81-100 floors
    Megatall = 'Megatall'   // 100+ floors
}

export enum DistanceCategory {
    Close = 'Close',    // 0-300m
    Medium = 'Medium',  // 301-700m
    Far = 'Far'        // 701m+
}

export interface LandPlotMetadata {
    rank: number;
    name: string;
    neighborhood: string;
    zoning: ZoningType;
    plotSize: PlotSize;
    buildingType: BuildingType;
    distances: {
        ocean: {
            meters: number;
            category: DistanceCategory;
        };
        bay: {
            meters: number;
            category: DistanceCategory;
        };
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plotArea: number;
}

export interface LandPlotMemory extends Memory {
    id: UUID;
    content: {
        text: string;
        metadata: LandPlotMetadata;
        source?: UUID;  // Optional source UUID to track origin of fragments
    };
}

export interface LandSearchParams {
    roomId?: UUID;
    agentId?: UUID;
    names?: string[];
    neighborhoods?: string[];
    zoningTypes?: ZoningType[];
    plotSizes?: PlotSize[];
    buildingTypes?: BuildingType[];
    distances?: {
        ocean?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
        bay?: {
            maxMeters?: number;
            category?: DistanceCategory;
        };
    };
    building?: {
        floors?: {
            min?: number;
            max?: number;
        };
        height?: {
            min?: number;
            max?: number;
        };
    };
    rarity?: {
        rankRange?: {
            min?: number;
            max?: number;
        };
    };
}

export interface LandKnowledgeItem {
    id: UUID;
    content: {
        text: string;
        metadata: any;
    };
}

export interface SearchSession {
    status: "ACTIVE" | "INACTIVE";
    lastQuery: string | null;
    results: any[];
    filters: Record<string, any>;
}

// Zod schema for search metadata
export const SearchMetadataSchema = z.object({
    searchText: z.string(),
    metadata: z.object({
        names: z.array(z.string()).optional(),
        neighborhoods: z.array(z.string()).optional(),
        zoningTypes: z.array(z.nativeEnum(ZoningType)).optional(),
        plotSizes: z.array(z.nativeEnum(PlotSize)).optional(),
        buildingTypes: z.array(z.nativeEnum(BuildingType)).optional(),
        distances: z.object({
            ocean: z.object({
                maxMeters: z.number().optional(),
                category: z.nativeEnum(DistanceCategory).optional()
            }).optional(),
            bay: z.object({
                maxMeters: z.number().optional(),
                category: z.nativeEnum(DistanceCategory).optional()
            }).optional()
        }).optional(),
        building: z.object({
            floors: z.object({
                min: z.number().optional(),
                max: z.number().optional()
            }).optional(),
            height: z.object({
                min: z.number().optional(),
                max: z.number().optional()
            }).optional()
        }).optional(),
        rarity: z.object({
            rankRange: z.object({
                min: z.number().optional(),
                max: z.number().optional()
            }).optional()
        }).optional()
    })
});

export type SearchMetadata = z.infer<typeof SearchMetadataSchema>;

// Constants
export const AGENT_ID: `${string}-${string}-${string}-${string}-${string}` = '1459b245-2171-02f6-b436-c3c2641848e5';
export const LAND_TABLE = 'land_table';
export const LAND_ROOM_ID = AGENT_ID;
export const LAND_AGENT_ID = AGENT_ID;
export const LAND_USER_ID = AGENT_ID;
export const DEFAULT_MATCH_THRESHOLD = 0.4;
export const DEFAULT_MATCH_COUNT = 20;

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/interfaces/ILandDataProvider.ts`:

```ts
import { LandPlotMemory, LandSearchParams } from '../types';
import { UUID } from '@ai16z/eliza';

export interface ILandDataProvider {
    createLandMemory(memory: LandPlotMemory): Promise<void>;
    getLandMemories(roomId: UUID): Promise<LandPlotMemory[]>;
    //removeAllLandMemories(roomId: UUID): Promise<void>;
    updateLandMemory(memory: LandPlotMemory): Promise<void>;
    searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]>;
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/initialSearchAction.ts`:

```ts
import { IAgentRuntime, Memory, State, Action, elizaLogger, HandlerCallback } from "@ai16z/eliza";
import { PropertySearchManager } from "./searchManager";

export const startPropertySearch: Action = {
    name: "START_PROPERTY_SEARCH",
    description: "Initiates a property search session for wilder world land properties",
    similes: ["SEARCH_PROPERTIES", "FIND_PROPERTIES", "LOOK_FOR_PROPERTIES"],
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "I'd like to look for wilder world land properties",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "sure I'll get your search session started. What kind of property are you looking for?",
                    action: "START_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Help me to search for Wilder World Land.",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I'll get your search session started.  What are you looking for?",
                    action: "START_PROPERTY_SEARCH",
                },
            },
        ],
    ],
    handler: async (
        runtime: IAgentRuntime,
        message: Memory,
        state: State,
        _options: any,
        callback?: HandlerCallback
    ): Promise<boolean> => {
            const searchManager = new PropertySearchManager(runtime);

            // In initialSearchAction.ts, replace the session initialization code with:
            await searchManager.initializeNewSearchSession(message.userId);

            const responseMsg = {
                text: `I'm ready to help you search for properties. What kind of property
 are you looking for? `,
                //content: {
                //    action: "START_PROPERTY_SEARCH",
                //}
            };


            callback(responseMsg);

            return true;
    },
    validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
        try {
            const searchManager = new PropertySearchManager(runtime);
            const userId = message.userId;

            // check if an active search session exists for the user
            const searchSession = await searchManager.getSearchSession(userId);

            if (searchSession?.status === "ACTIVE") {
                elizaLogger.info("An active search session already exists for the user.");
                return false;
            }
            console.log("VALIDATE startPropertySearch validated");

            return true;
        } catch (error) {
            elizaLogger.error("Failed to validate property search:", error);
            return false;
        }
    }
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/endSearchAction.ts`:

```ts
import { IAgentRuntime, Memory, State, Action, elizaLogger, HandlerCallback } from "@ai16z/eliza";
import { PropertySearchManager } from "./searchManager";

export const endPropertySearch: Action = {
    name: "END_PROPERTY_SEARCH",
    description: "Ends the current property search session",
    similes: ["STOP_SEARCH", "END_SEARCH", "FINISH_SEARCH", "CANCEL_SEARCH"],
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "I'm done searching for properties",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've ended your property search session. Let me know if you'd like to start a new search!",
                    action: "END_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "End my property search",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "I've cancelled your property search session. Feel free to start a new search anytime!",
                    action: "END_PROPERTY_SEARCH",
                },
            },
        ],
    ],
    handler: async (
        runtime: IAgentRuntime,
        message: Memory,
        state?: State,
        options?: any,
        callback?: HandlerCallback
    ) => {
        const searchManager = new PropertySearchManager(runtime);
        await searchManager.endSearchSession(message.userId);

        callback({
            text: "Wilder World property Search session ended."
        });
        return true;
    },
    validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
        const searchManager = new PropertySearchManager(runtime);
        const session = await searchManager.getSearchSession(message.userId);

        // Only allow ending active sessions
        if (!session || session.status !== "ACTIVE") {
            return false;
        }
        console.log("VALIDATE endPropertySearch validated");
        return true;
    },
};
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/database/land_memory_system.ts`:

```ts
import { elizaLogger, UUID, stringToUuid, splitChunks } from "@ai16z/eliza";
import { LandPlotMemory,
    LandSearchParams,
    DEFAULT_MATCH_COUNT,
    LandKnowledgeItem,
    LandPlotMetadata,
    ZoningType,
    PlotSize,
    BuildingType,
    DistanceCategory,
    LAND_TABLE
} from "../types";
import { LAND_ROOM_ID, LAND_AGENT_ID, AGENT_ID } from "../types";
import { v4 as uuidv4 } from 'uuid';
import { ILandDataProvider } from '../interfaces/ILandDataProvider';

export const LAND_QUERY_SYSTEM_PROMPT = `
You are a real estate search assistant for a futuristic city. Convert natural language queries into structured search parameters.

Given a user query, respond with a JSON object containing:
1. A natural language description for embedding matching
2. Search metadata parameters

Example Response Format:
{
    "searchText": "Large plot in Nexus neighborhood close to ocean with tall building potential",
    "metadata": {
        "neighborhood": "Nexus",
        "minPlotArea": 5000,
        "maxOceanDistance": 500,
        "minFloors": 50
    }
}

Keep the searchText natural and descriptive while being specific about requirements.
`;

export class LandMemorySystem {
    private readonly roomId: UUID = LAND_ROOM_ID;
    private readonly agentId: UUID = LAND_AGENT_ID;
    private readonly userId: UUID = AGENT_ID;

    constructor(
        private readonly dataProvider: ILandDataProvider,
    ) {}

/*     async removeAllLandMemories(): Promise<void> {
        await this.dataProvider.removeAllLandMemories(this.roomId);
    }
 */
    async createLandMemoryFromCSV(csvRow: any): Promise<void> {
        try {
            const metadata: LandPlotMetadata = {
                rank: parseInt(csvRow['Rank']),
                name: csvRow['Name'],
                neighborhood: csvRow['Neighborhood'],
                zoning: csvRow['Zoning Type'],
                plotSize: csvRow['Plot Size'],
                buildingType: csvRow['Building Size'],
                distances: {
                    ocean: {
                        meters: parseInt(csvRow['Distance to Ocean (m)']),
                        category: csvRow['Distance to Ocean']
                    },
                    bay: {
                        meters: parseInt(csvRow['Distance to Bay (m)']),
                        category: csvRow['Distance to Bay']
                    }
                },
                building: {
                    floors: {
                        min: parseInt(csvRow['Min # of Floors']),
                        max: parseInt(csvRow['Max # of Floors'])
                    },
                    height: {
                        min: parseFloat(csvRow['Min Building Height (m)']),
                        max: parseFloat(csvRow['Max Building Height (m)'])
                    }
                },
                plotArea: parseFloat(csvRow['Plot Area (m²)'])
            };

            await this.storeProperty(metadata);
        } catch (error) {
            elizaLogger.error('Error creating land memory:', {
                error: error instanceof Error ? error.message : String(error),
                csvRow
            });
            throw error;
        }
    }

    async searchPropertiesByParams(searchParams: Partial<LandSearchParams> = {}): Promise<LandPlotMemory[]> {
        const results = await this.dataProvider.searchLandByMetadata(searchParams);
        return results;
    }

    async mockSearchPropertiesByParams(searchParams: Partial<LandSearchParams> = {}): Promise<LandPlotMemory[]> {
        const mockProperty: LandPlotMemory = {
            id: '94e9f251-1ec7-0bde-b9cc-0fffa695eebf',
            content: {
                text: 'Oceanview Residence is a Large Residential plot in Coastal District. It is located 150m from the ocean and 2000m from the bay. The building can have between 5 and 8 floors, with heights from 15m to 24m. The plot area is 2500m².',
                metadata: {
                    name: 'Oceanview Residence',
                    rank: 1,
                    zoning: ZoningType.Residential,
                    building: {
                        floors: { max: 8, min: 5 },
                        height: { max: 24, min: 15 }
                    },
                    plotArea: 2500,
                    plotSize: PlotSize.Macro, //'Large',
                    distances: {
                        bay: { meters: 2000, category: DistanceCategory.Far },
                        ocean: { meters: 150, category: DistanceCategory.Close }
                    },
                    buildingType: BuildingType.Midrise, //'MidRise',
                    neighborhood: 'Coastal District'
                }
            },
            userId: '1459b245-2171-02f6-b436-c3c2641848e5',
            agentId: '1459b245-2171-02f6-b436-c3c2641848e5',
            roomId: '1459b245-2171-02f6-b436-c3c2641848e5',
            unique: true
        };

        return [mockProperty];
    }

    /**
     * Get properties within a specific rarity range
     */
/*     async getPropertiesByRarity(
        minRank: number,
        maxRank: number,
        limit: number = DEFAULT_MATCH_COUNT
    ): Promise<LandPlotMemory[]> {
        try {
            const results = await this.dataProvider.getPropertiesByRarityRange(minRank, maxRank);
            return results.slice(0, limit);
        } catch (error) {
            elizaLogger.error('Error getting properties by rarity:', {
                error: error instanceof Error ? error.message : String(error),
                minRank,
                maxRank
            });
            throw error;
        }
    }
 */
    async storePropertyItem(
        item: LandKnowledgeItem,
        chunkSize: number = 512,
        bleed: number = 20
    ): Promise<UUID> {
        try {
            // First create the main land memory
            const mainMemory: LandPlotMemory = {
                id: item.id,
                userId: this.userId,
                agentId: this.agentId,
                roomId: this.roomId,
                content: item.content
                //embedding: await this.embedder.embedText(item.content.text)
            };
            await this.dataProvider.createLandMemory(mainMemory);
            return item.id;
        } catch (error) {
            elizaLogger.error('Error setting land knowledge:', {
                error: error instanceof Error ? error.message : String(error),
                item
            });
            throw error;
        }
    }


    /**
     * Stores a property in the land memory system
     * @param metadata The land plot metadata to store
     * @returns The UUID of the stored property
     */
    async storeProperty(metadata: LandPlotMetadata): Promise<UUID> {
        const description = this.generatePropertyDescription(metadata);
        const knowledgeItem: LandKnowledgeItem = {
            id: stringToUuid(description+Date.now()),
            content: {
                text: description,
                metadata: metadata
            },
        };

        return await this.storePropertyItem(knowledgeItem);
    }

    /**
     * Generates a natural language description of a property from its metadata
     */
    private generatePropertyDescription(metadata: LandPlotMetadata): string {
        const description = `${metadata.name} is a ${metadata.plotSize} ${metadata.zoning} plot in ${metadata.neighborhood}. ` +
            `It is located ${metadata.distances.ocean.meters}m from the ocean and ${metadata.distances.bay.meters}m from the bay. ` +
            `The building can have between ${metadata.building.floors.min} and ${metadata.building.floors.max} floors, ` +
            `with heights from ${metadata.building.height.min}m to ${metadata.building.height.max}m. ` +
            `The plot area is ${metadata.plotArea}m².`;
        return description;
    }
}
```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/database/land_database_adapter.ts`:

```ts
import { IDatabaseAdapter } from "@ai16z/eliza";
import { elizaLogger, UUID } from "@ai16z/eliza";
import PostgresDatabaseAdapter from "@ai16z/adapter-postgres";
import {
    LandPlotMemory,
    LandSearchParams,
    LAND_TABLE,
    LAND_ROOM_ID,
    LAND_AGENT_ID,
    DEFAULT_MATCH_THRESHOLD
} from "../types";

const LAND_MEMORY_TYPE = 'land_plot';

export class LandDatabaseAdapter {
    private dbAdapter: IDatabaseAdapter;

    constructor(configOrAdapter: IDatabaseAdapter) {
        this.dbAdapter = configOrAdapter;
    }

    async init(): Promise<void> {
        await this.dbAdapter.init();
        // Add any additional initialization specific to LandDatabaseAdapter if needed
    }

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        console.log("Creating land memory with :", memory.content.metadata.name);
        // await this.dbAdapter.createMemory(memory, LAND_MEMORY_TYPE, true, LAND_TABLE);
    }

    async getLandMemoryById(id: UUID): Promise<LandPlotMemory | undefined> {
        const memory = null //await this.dbAdapter.getMemoryById(id, LAND_MEMORY_TYPE, LAND_TABLE);
        if (!memory) return undefined;
        return memory as LandPlotMemory;
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
/*         const memories = await this.dbAdapter.getMemories({
            roomId,
            tableName: LAND_MEMORY_TYPE,
            dbTable: LAND_TABLE
        });
        return memories as LandPlotMemory[]; */
        return null
    }

/*     async removeLandMemory(memoryId: UUID): Promise<void> {
        await this.dbAdapter.removeMemory(memoryId, LAND_MEMORY_TYPE, LAND_TABLE);
    }

    async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.dbAdapter.removeAllMemories(roomId, LAND_MEMORY_TYPE, LAND_TABLE);
    } */

    async searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]> {
        let sql = `
            SELECT * FROM ${LAND_TABLE}
            WHERE type = $1
            AND content IS NOT NULL
        `;
        const values: any[] = [LAND_MEMORY_TYPE];
        let paramCount = 1;

        // Add names condition
        if (params.names?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'name' = ANY($${paramCount}::text[])`;
            values.push(params.names);
        }

        if (params.neighborhoods?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'neighborhood' = ANY($${paramCount}::text[])`;
            values.push(params.neighborhoods);
        }

        if (params.zoningTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'zoning' = ANY($${paramCount}::text[])`;
            values.push(params.zoningTypes);
        }

        if (params.plotSizes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'plotSize' = ANY($${paramCount}::text[])`;
            values.push(params.plotSizes);
        }

        if (params.buildingTypes?.length) {
            paramCount++;
            sql += ` AND content->'metadata'->>'buildingType' = ANY($${paramCount}::text[])`;
            values.push(params.buildingTypes);
        }

        if (params.distances?.ocean) {
            if (params.distances.ocean.maxMeters) {
                paramCount++;
                sql += ` AND (content->'metadata'->'distances'->'ocean'->>'meters')::int <= $${paramCount}`;
                values.push(params.distances.ocean.maxMeters);
            }
            if (params.distances.ocean.category) {
                paramCount++;
                sql += ` AND content->'metadata'->'distances'->'ocean'->>'category' = $${paramCount}`;
                values.push(params.distances.ocean.category);
            }
        }

        if (params.distances?.bay) {
            if (params.distances.bay.maxMeters) {
                paramCount++;
                sql += ` AND (content->'metadata'->'distances'->'bay'->>'meters')::int <= $${paramCount}`;
                values.push(params.distances.bay.maxMeters);
            }
            if (params.distances.bay.category) {
                paramCount++;
                sql += ` AND content->'metadata'->'distances'->'bay'->>'category' = $${paramCount}`;
                values.push(params.distances.bay.category);
            }
        }
        if (params.building?.floors) {
            if (params.building.floors.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'min')::int >= $${paramCount}`;
                values.push(params.building.floors.min);
            }
            if (params.building.floors.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->'building'->'floors'->>'max')::int <= $${paramCount}`;
                values.push(params.building.floors.max);
            }
        }

        if (params.rarity?.rankRange) {
            if (params.rarity.rankRange.min) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int >= $${paramCount}`;
                values.push(params.rarity.rankRange.min);
            }
            if (params.rarity.rankRange.max) {
                paramCount++;
                sql += ` AND (content->'metadata'->>'rank')::int <= $${paramCount}`;
                values.push(params.rarity.rankRange.max);
            }
        }

        try {
            const { rows } = await (this.dbAdapter as PostgresDatabaseAdapter).query(sql, values);
            return rows.map(row => ({
                ...row,
                content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content
            }));
        } catch (error) {
            elizaLogger.error('Error in searchLandByMetadata:', {
                error: error instanceof Error ? error.message : String(error),
                params
            });
            throw error;
        }
    }


    async getPropertiesByRarityRange(
        minRank: number,
        maxRank: number
    ): Promise<LandPlotMemory[]> {
        return this.searchLandByMetadata({
            rarity: {
                rankRange: {
                    min: minRank,
                    max: maxRank
                }
            }
        });
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/nft/types_NFT.ts`:

```ts
export interface NFTPrice {
    tokenId: string;
    price: number;
}

export interface ReservoirResponse {
    tokens: Record<string, number>;
}

export interface NFTPriceCache {
    lastUpdated: Date;
    prices: NFTPrice[];
    collection: string;
}

export interface NFTPriceProvider {
    getPricesForCollection(collectionAddress: string): Promise<NFTPrice[]>;
    getCachedPrices(collectionAddress: string): Promise<NFTPriceCache | null>;
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/nft/ReservoirAPI.ts`:

```ts
import { NFTPrice, NFTPriceCache, NFTPriceProvider, ReservoirResponse } from './types_NFT';

export class ReservoirAPI implements NFTPriceProvider {
    private readonly apiKey: string;
    private readonly baseUrl: string;
    private cache: Map<string, NFTPriceCache>;

    constructor(apiKey: string, baseUrl: string = 'https://api.reservoir.tools') {
        this.apiKey = apiKey;
        this.baseUrl = baseUrl;
        this.cache = new Map();
    }

    private async fetchFromAPI(collectionAddress: string): Promise<ReservoirResponse> {
        const options = {
            method: 'GET',
            headers: {
                'accept': '*/*',
                'x-api-key': this.apiKey
            }
        };

        const response = await fetch(
            `${this.baseUrl}/tokens/floor/v1?collection=${collectionAddress}`,
            options
        );

        if (!response.ok) {
            throw new Error(`API request failed: ${response.statusText}`);
        }

        return response.json();
    }

    async getPricesForCollection(collectionAddress: string): Promise<NFTPrice[]> {
        try {
            const data = await this.fetchFromAPI(collectionAddress);
            const prices: NFTPrice[] = Object.entries(data.tokens).map(([tokenId, price]) => ({
                tokenId,
                price
            }));

            // Update cache
            this.cache.set(collectionAddress, {
                lastUpdated: new Date(),
                prices,
                collection: collectionAddress
            });

            return prices;
        } catch (error) {
            console.error('Error fetching NFT prices:', error);
            throw error;
        }
    }

    async getCachedPrices(collectionAddress: string): Promise<NFTPriceCache | null> {
        return this.cache.get(collectionAddress) || null;
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/searchManager.ts`:

```ts
import { LandMemorySystem } from './database/land_memory_system';
import { LandSearchParams, LandPlotMemory, SearchMetadata, SearchMetadataSchema, ZoningType, PlotSize, BuildingType } from './types';
import { IAgentRuntime } from '@ai16z/eliza';
import { PostgresLandDataProvider } from './adapters/PostgresLandDataProvider';
import { LandDatabaseAdapter } from './database/land_database_adapter';
import { PostgresDatabaseAdapter } from "@ai16z/adapter-postgres";
import { elizaLogger } from "@ai16z/eliza";

interface PropertyResult {
    rank: number;
    name: string;
    neighborhood: string;
    zoningType: string;
    plotSize: string;
    buildingSize: string;
    distances: {
        ocean: number;
        bay: number;
    };
    building: {
        floors: {
            min: number;
            max: number;
        };
        height: {
            min: number;
            max: number;
        };
    };
    plotArea: number;
}

export interface SearchSession {
    status: "ACTIVE" | "INACTIVE";
    lastQuery: string | null;
    results: LandPlotMemory[];
    filters: Partial<LandSearchParams>;
}

export class PropertySearchManager {
    private memorySystem: LandMemorySystem;

    constructor(private runtime: IAgentRuntime) {
        //elizaLogger.info("🚀 Initializing PropertySearchManager...");

        if (!runtime.databaseAdapter) {
            throw new Error("Database adapter not found in runtime");
        }

        //elizaLogger.info("✅ Using database adapter:", runtime.databaseAdapter.constructor.name);

        const dbAdapter = new LandDatabaseAdapter(runtime.databaseAdapter);
        const landDataProvider = new PostgresLandDataProvider(dbAdapter);
        this.memorySystem = new LandMemorySystem(landDataProvider);

        elizaLogger.info("✅ PropertySearchManager initialization complete");
    }

    async createSearchSession(userId: string, initialState: SearchSession) {
        await this.runtime.cacheManager.set(`property-search-${userId}`, initialState);
    }

    async initializeNewSearchSession(userId: string): Promise<SearchSession> {
        const initialSession: SearchSession = {
            status: "ACTIVE",
            lastQuery: null,
            results: [],
            filters: {}
        };

        await this.createSearchSession(userId, initialSession);
        return initialSession;
    }

    async endSearchSession(userId: string): Promise<SearchSession | null> {
        const session = await this.runtime.cacheManager.get<SearchSession>(
            `property-search-${userId}`
        );

        if (session) {
            // Update the session status to INACTIVE
            const endedSession: SearchSession = {
                ...session,
                status: "INACTIVE"
            };

            // Save the updated session state
            await this.runtime.cacheManager.set(
                `property-search-${userId}`,
                endedSession
            );

            return endedSession;
        }

        return null;
    }

    async getSearchSession(userId: string): Promise<SearchSession | null> {
        const session = await this.runtime.cacheManager.get<SearchSession>(
            `property-search-${userId}`
        );
        return session || null;
    }

    async updateSearchResults(userId: string, results: LandPlotMemory[]) {
        const session = await this.getSearchSession(userId);
        if (!session) return;

        session.results = results;
        await this.runtime.cacheManager.set(`property-search-${userId}`, session);
    }

    async executeSearch(searchMetadata: SearchMetadata): Promise<LandPlotMemory[] | null> {
        const { metadata } = searchMetadata;
        const searchParams: Partial<LandSearchParams> = {};

        // Handle names array
        if (metadata.names?.length) {
            searchParams.names = metadata.names;
        }
        // Handle array fields with proper typing
        if (metadata.neighborhoods?.length) {
            searchParams.neighborhoods = metadata.neighborhoods;
        }
        if (metadata.zoningTypes?.length) {
            searchParams.zoningTypes = metadata.zoningTypes as ZoningType[];
        }
        if (metadata.plotSizes?.length) {
            searchParams.plotSizes = metadata.plotSizes as PlotSize[];
        }
        if (metadata.buildingTypes?.length) {
            searchParams.buildingTypes = metadata.buildingTypes as BuildingType[];
        }

        // Handle distances
        if (metadata.distances?.ocean || metadata.distances?.bay) {
            searchParams.distances = {};
            ['ocean', 'bay'].forEach(type => {
                const distance = metadata.distances?.[type];
                if (distance) {
                    searchParams.distances![type] = {
                        maxMeters: distance.maxMeters,
                        category: distance.category
                    };
                }
            });
        }

        // Handle building
        if (metadata.building?.floors || metadata.building?.height) {
            searchParams.building = {};
            ['floors', 'height'].forEach(prop => {
                const value = metadata.building?.[prop];
                if (value) {
                    searchParams.building![prop] = value;
                }
            });
        }

        // Handle rarity
        if (metadata.rarity?.rankRange) {
            searchParams.rarity = { rankRange: metadata.rarity.rankRange };
        }

        // Return null if no search parameters were defined
        if (Object.keys(searchParams).length === 0) {
            return null;
        }

        console.log('Search parameters:', searchParams);
        return await this.memorySystem.searchPropertiesByParams(searchParams);
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/adapters/PostgresLandDataProvider.ts`:

```ts
import { LandDatabaseAdapter } from '../database/land_database_adapter';
import { ILandDataProvider } from '../interfaces/ILandDataProvider';
import { LandPlotMemory, LandSearchParams } from '../types';
import { UUID } from '@ai16z/eliza';

export class PostgresLandDataProvider implements ILandDataProvider {
    constructor(private readonly dbAdapter: LandDatabaseAdapter) {}

    async createLandMemory(memory: LandPlotMemory): Promise<void> {
        await this.dbAdapter.createLandMemory(memory);
    }

    async getLandMemories(roomId: UUID): Promise<LandPlotMemory[]> {
        return await this.dbAdapter.getLandMemories(roomId);
    }

/*     async removeAllLandMemories(roomId: UUID): Promise<void> {
        await this.dbAdapter.removeAllLandMemories(roomId);
    } */

    async updateLandMemory(memory: LandPlotMemory): Promise<void> {
        // TODO: Implement this method in LandDatabaseAdapter
        throw new Error('Method not implemented: updateLandMemory');
    }

    async searchLandByMetadata(params: LandSearchParams): Promise<LandPlotMemory[]> {
        return await this.dbAdapter.searchLandByMetadata(params);
    }
}

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/src/searchProcessingAction.ts`:

```ts
import { Action, IAgentRuntime, Memory, State,
    ModelClass,
    composeContext,
    generateObject,
    generateText,
    HandlerCallback
} from "@ai16z/eliza";
import * as fs from "fs";
import * as path from "path";

import { PropertySearchManager } from "./searchManager";
//import { generateObjectV2 } from "@ai16z/eliza";
import { LAND_QUERY_SYSTEM_PROMPT } from "./database/land_memory_system";
import { LandPlotMemory, SearchMetadataSchema } from "./types";
import { z } from "zod";

export const processPropertySearch: Action = {
    name: "PROCESS_PROPERTY_SEARCH",
    similes: ["SEARCH_WILDER_LAND","LAND_SEARCH"],
    description: "Processes a wilder world land property search in the land memory database and returns results",
    examples: [
        [
            {
                user: "{{user1}}",
                content: {
                    text: "give me all properties in space mind with a view of the ocean",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Searching for space mind properties:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "What are all legendary plots close to the bay",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Searching for legendary plots close to the bay:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "How does the plot size of FL-45 compare to other residential properties in Flashing Lights?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Analyzing plot size comparison in Flashing Lights:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "How many plots in Tranquility Gardens are close to the Ocean?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Searching for oceanfront plots in Tranquility Gardens:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
        [
            {
                user: "{{user1}}",
                content: {
                    text: "Which SM property is closest to the Ocean?",
                },
            },
            {
                user: "{{user2}}",
                content: {
                    text: "Finding closest Space Mind property to ocean:",
                    action: "PROCESS_PROPERTY_SEARCH",
                },
            },
        ],
    ],
    handler: async (runtime: IAgentRuntime,
        message: Memory,
        state: State | undefined,
        options: any,
        callback: HandlerCallback
    ) => {
        if (!state) {
            throw new Error('State is required for property search processing');
        }
        // read from file
        const promptDir = path.join(process.cwd(), 'prompts');
        const landPromptFile = path.join(promptDir, 'land_query_prompt.txt');
        const queryPromptFile = path.join(promptDir, 'query_extraction_prompt.txt');

        const searchManager = new PropertySearchManager(runtime);

        const QUERY_EXTRACTION_SYSTEM_PROMPT = fs.readFileSync(
            queryPromptFile,
            'utf-8'
        );

        // TODO: parse recent messages to filter out very long messages
        const recentMessages = await runtime.messageManager.getMemories({
            roomId: message.roomId,
            count: 6,
        });
        // iterate through recentMessages and filter out very long messages
        const filteredRecentMessages = recentMessages.filter((msg) =>
            msg.content.text.length <= 1000);

        // add filtered recent messages to context
        const context = composeContext({
            state: {
                ...state,
                recentMessagesData: filteredRecentMessages
            },
            template: QUERY_EXTRACTION_SYSTEM_PROMPT,
        });

        //console.log("Composed context:", context);

        const searchQuery = await generateText({
            runtime,
            context,
            modelClass: ModelClass.SMALL,
        });

        console.log("Generated search query:", searchQuery);

        callback({
            text: 'Asking ATLAS: ' + searchQuery
        });

        const FILE_LAND_QUERY_SYSTEM_PROMPT = fs.readFileSync(
            landPromptFile,
            'utf-8'
        );

        const landQueryContext = FILE_LAND_QUERY_SYSTEM_PROMPT + searchQuery;

        //console.log("Land query context:", landQueryContext);

        const metadataResult = await generateObject({
            runtime,
            context: landQueryContext,
            modelClass: ModelClass.SMALL,
            schema: SearchMetadataSchema,
        });

        if (!metadataResult?.object) {
            throw new Error('Failed to generate search metadata');
        }

        console.log("Generated search metadata object: ", metadataResult.object);

        // Execute search
        const results = await searchManager.executeSearch(metadataResult.object);

        if (!!results) {
            await searchManager.updateSearchResults(message.userId, results);
        };

        // log the names of the properties in results.content.metadata.name
        // separated by a space and a comma
        console.log("Search results names:", results.map((result) => result.content.metadata.name).join(", "));

        // Format response
        const formattedResponse = formatSearchResults(results);

        callback({
            text: formattedResponse
        });

        return true;
    },
    validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
        const searchManager = new PropertySearchManager(runtime);
        const session = await searchManager.getSearchSession(message.userId);

        console.log("PROCESS_PROPERTY_SEARCH validate session status= ", session?.status);
        console.log("#results in session= ", session?.results.length);
        const isValid = !!session && session.status === "ACTIVE";
        if  (isValid) {
            console.log("VALIDATE: processPropertySearch validated");
        }
        return isValid;
    }
};

function formatSearchResults(landMemories: LandPlotMemory[]): string {
    if (landMemories.length === 0) {
        return "I couldn't find any properties matching your criteria. Would you like to try a different search?";
    }

    let response = `I found ${landMemories.length} properties matching your criteria: (first 10 shown)\n\n`;

    landMemories.slice(0, 10).forEach(property => {
        const metadata = property.content.metadata;
        response += `${metadata.name} in ${metadata.neighborhood}: ${metadata.zoning}  \n`;
        response += `- Plot size: ${metadata.plotSize} (${metadata.plotArea}m²)  ${metadata.buildingType} `;
        response += `  |  Floors: ${metadata.building.floors.min}-${metadata.building.floors.max}`;
        response += `  |  Distance To Ocean: ${metadata.distances.ocean.meters}m (${metadata.distances.ocean.category}) `;
        response += ` To Bay: ${metadata.distances.bay.meters}m (${metadata.distances.bay.category})\n\n`;
    });
    return response;
}

        // Generate search metadata using LLM
/*          const searchMetadata = (await generateObjectV2({
            runtime,
            context,
            modelClass: ModelClass.LARGE,
            schema: SearchMetadataSchema,
        })) as z.infer<typeof SearchMetadataSchema>; */

```

`/home/kai/eliza/ke/kai-eliza/packages/plugin-unreal/scripts/seed-database.ts`:

```ts
import { config } from 'dotenv';
import { parse } from 'csv-parse';
import { createReadStream } from 'fs';
import { LandDatabaseAdapter } from '../src/database/land_database_adapter';
import { PostgresLandDataProvider } from '../src/adapters/PostgresLandDataProvider';
import { LandPlotMemory, ZoningType, PlotSize, BuildingType, DistanceCategory, AGENT_ID } from '../src/types';
import { PostgresDatabaseAdapter } from '@ai16z/adapter-postgres';
import { UUID } from '@ai16z/eliza';

// Load environment variables
//config();

async function seedDatabase() {
    // Initialize database connection
    const dbAdapter = new PostgresDatabaseAdapter({
        connectionString: process.env.POSTGRES_URL || 'postgresql://postgres:postgres@localhost:5432/test',
        max: 20,
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000
    });

    await dbAdapter.init();

    const landDbAdapter = new LandDatabaseAdapter(dbAdapter);
    const landDataProvider = new PostgresLandDataProvider(landDbAdapter);

    // Read CSV file
    const parser = parse({
        delimiter: ',',
        columns: true,
        skip_empty_lines: true
    });

    const records: LandPlotMemory[] = [];

    createReadStream('./data/land_plots.csv')
        .pipe(parser)
        .on('data', async (row) => {
            console.log('Building Size from CSV:', row['Building Size']); // Add this line
            const memory: LandPlotMemory = {
                id: row.id,
                userId: AGENT_ID,
                agentId: AGENT_ID,
                roomId: AGENT_ID,
                content: {
                    text: row.description,
                    metadata: {
                        rank: parseInt(row['Rank']),
                        name: row['Name'],
                        neighborhood: row['Neighborhood'],
                        zoning: row['Zoning Type'] as ZoningType,
                        plotSize: row['Plot Size'] as PlotSize,
                        buildingType: row['Building Size'] as BuildingType,
                        building: {
                            floors: {
                                min: parseInt(row['Min # of Floors']),
                                max: parseInt(row['Max # of Floors'])
                            },
                            height: {
                                min: parseInt(row['Min Building Height (m)']),
                                max: parseInt(row['Max Building Height (m)'])
                            }
                        },
                        plotArea: parseInt(row['Plot Area (m²)']),
                        distances: {
                            ocean: {
                                meters: parseInt(row['Distance to Ocean (m)']),
                                category: row['Distance to Ocean'] as DistanceCategory
                            },
                            bay: {
                                meters: parseInt(row['Distance to Bay (m)']),
                                category: row['Distance to Bay'] as DistanceCategory
                            }
                        }
                    }
                }
            };
            records.push(memory);
        })
        .on('end', async () => {
            try {
                // Batch insert records
                for (const record of records) {
                    await landDataProvider.createLandMemory(record);
                }
                console.log(`Successfully seeded ${records.length} records`);
                process.exit(0);
            } catch (error) {
                console.error('Error seeding database:', error);
                process.exit(1);
            }
        });
}

seedDatabase().catch(console.error);

```